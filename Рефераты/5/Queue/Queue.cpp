#include <iostream>
using namespace std;

// Определение структуры узла для очереди
struct node
{
    int elem;    // Элемент данных
    node* sled;  // Указатель на следующий узел
};

// Класс для работы с очередью
class Spisok {
private:
    node* no, * ko;  // Указатели на начало очереди и ее конец
    int klad;        // Переменная для хранения элемента, удаленного из очереди
public:
    // Конструктор класса
    Spisok()
    {
        no = ko = NULL;  // Начальная нициализация указателей на начало и конец как NULL
    }
    // Методы для класса
    void POSTROENIE();   // Построение очереди
    void VYVOD();        // Вывод содержимого очереди
    void DOBAVLENIE(int);  // Добавление элемента в очередь
    int SetUdal() { return klad; }  // Получение инфо-поля(или просто содержания) удаленного узла
    void YDALENIE();  // Удаление элемента из очереди
    void OCHISTKA();  // Очистка очереди
};

// Точка входа в программу
int main()
{
    setlocale(LC_ALL, "Rus");  
    Spisok A;  // Создание элемента класса Spisok
    int el;  // Переменная для хранения вводимых пользователем элементов

    A.POSTROENIE();  // Построение очереди
    A.VYVOD();       // Вывод содержимого очереди

    cout << "Введите добавляемый элемент: ";
    cin >> el;
    A.DOBAVLENIE(el);  // Добавление элемента в очередь
    A.VYVOD();         // Вывод обновленной очереди

    cout << "Удалим элемент из очереди.\n";
    A.YDALENIE();  // Удаление элемента из очереди
    A.VYVOD();     // Вывод обновленной очереди

    el = A.SetUdal();  // Получение содердания удаленного узла
    cout << "Информационное поле удаленного звена: " << el << endl;

    A.OCHISTKA();  // Очистка очереди

    cout << "\n";
    system("PAUSE");
}

void Spisok::POSTROENIE()
{
    node* r;  // Объявление рабочего указателя
    int el;   // Переменная для хранения вводимых пользователем элементов

    cout << "Введите элементы очереди: ";  
    cin >> el;  // Ввод первого элемента очереди

    if (el != 0)  // Проверка, не является ли первый элемент нулем то есит завершающим элементом
    {
        r = new (node);  // Выделение памяти для нового узла
        (*r).elem = el;  // Присваивание нового значения (введенного пользователем) элементу узла
        (*r).sled = NULL;  // Установка указателя на следующий узел в NULL, так как это первый узел
        no = r;  // Установка указателя начала очереди на созданный узел
        ko = r;  // Установка указателя конца очереди на созданный узел
        cin >> el;  // Ввод следующего элемента очереди
        while (el != 0)  // Пока вводимые пользователм элементы не "0" (пока очередь не закончена)
        {
            r = new (node);  // Выделение памяти под новый узел
            (*r).elem = el;  // Присваивание нового значения (введенного пользователем) элементу узла
            (*r).sled = NULL;  // Установка указателя на следующий узел в NULL
            (*ko).sled = r;  // Установка указателя на следующий узел предыдущего узла на новый узел
            ko = r;  // Перемещение указателя на конец очереди на новый узел
            cin >> el;  // Ввод след. элемента очереди
        }
    }
    else  // Если введенный элемент = 0 (завершающий элемент)
    {
        r = NULL;  // Устанавливаем указатель на узел в NULL
        no = r;  // Устанавливаем указатель на начало очереди в NULL
        ko = r;  // Устанавливаем указатель на конец очереди в NULL
    }
}


void Spisok::VYVOD()
{
    node* r;  // Объявление указателя на узел
    cout << "Очередь: ";  
    r = no; // указатель на начало очереди

    while (r != NULL)  // Пока пока не дойдем до конца очереди
    {
        cout << (*r).elem << " ";  // Выводим значение текущего узла
        r = (*r).sled;  // Переход к следующему узлу 
    }

    cout << endl;  
}

void Spisok::DOBAVLENIE(int el)
{
    node* r;  // Объявление рабочего указателя на узел

    r = new (node);  // Выделение памяти под новый узел
    (*r).elem = el;  // Присваивание значения элементу узла
    (*r).sled = NULL;  // Установка указателя на следующий узел в NULL

    if (no != NULL)  // Проверка, не пуста ли очередь
    {
        (*ko).sled = r;  // Установка указателя на след. узел последнего узла на новый узел
        ko = r;  // Перемещение указателя на конец очереди на новый узел
    }
    else  // Если очередь пуста
    {
        no = r;  // Устанавливаем указатель начала очереди на новый узел
        ko = r;  // Устанавливаем указатель конца очереди на новый узел
    }
}


void Spisok::YDALENIE()
{
    node* q;  // Объявление рабочего указателя на узел

    if (no == NULL)  // Проверка, пуста ли очередь
    {
        cout << "Удалить элемент нельзя, так как очередь пуста!\n";  
    }
    else
    {
        klad = (*no).elem;  // Сохранение значения элемента, который будет удален (Совет Бывалого)
        q = no;  // Присваивание указателю q адреса первого узла в очереди
        no = (*no).sled;  // Перемещение указателя начала очереди на след. узел
        delete q;  // Удаление первого узла
    }
}


void Spisok::OCHISTKA()
{
    node* q;  // Объявление указателя на узелk

    q = no;  // Присваивание указателю q адреса начала очереди

    if (no != NULL)  // Проверка, не является ли очередь пустой
    {
        while (no != ko)  // будет выполняться, пока не достигнут конец очереди
        {
            no = (*q).sled;  // Перемещение указателя начала очереди на следующий узел
            delete q;  // Удаление текущего узла
            q = no;  // Перемещение указателя q на след. узел
        }

        delete no;  // Удаление последнего узла очереди
        no = ko = NULL;  // Установка указателей конца и начала  в NULL
    }
}
