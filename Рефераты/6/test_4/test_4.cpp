#include <conio.h> // Подключение библиотеки для работы с консольным вводом/выводом
#include <iostream> // Подключение библиотеки для работы с потоками ввода/вывода
using namespace std; // Использование стандартного пространства имён

// Определение структуры узла дерева
struct node
{
    int key; // Ключ узла
    int count; // Счётчик
    node* Left; // Указатель на левое поддерево
    node* Right; // Указатель на правое поддерево
};

// Определение класса для работы с деревом
class Tree
{
private:
    node* root; // Корень дерева
    void  DisposeTree(node*); // Метод для удаления дерева
    void  printTree(node*, int); // Метод для вывода дерева на экран
    void  Delete(node**, int); // Метод для удаления узла из дерева
    void  del(node**, node*); // Вспомогательный метод для удаления узла из дерева
public:
    Tree() { root = NULL; }; // Конструктор класса
    ~Tree(); // Деструктор класса
    void creat_Tree(); // Метод для создания дерева
    void look_Tree(); // Метод для вывода дерева на экран
    void add_Tree(); // Метод для добавления узла в дерево
    void delete_Tree(); // Метод для удаления узла из дерева
    void search(int, node**); // Метод для поиска узла по ключу
    node* getTree() { return root; }; // Метод для получения корня дерева
};

// Определение структуры элемента кольца
struct zveno
{
    int element; // Элемент кольца
    Tree ukTree; // Дерево, связанное с элементом кольца
    zveno* sled; // Указатель на следующий элемент кольца
};

// Определение класса для работы с кольцом
class ring
{
private:
    zveno* ukring; // Указатель на первый элемент кольца
public:
    ring() { ukring = NULL; }; // Конструктор класса
    ~ring(); // Деструктор класса
    void create(); // Метод для построения кольца
    void look(); // Метод для вывода содержимого кольца
    void add_after(int, zveno*); // Метод для добавления элемента после указанного элемента кольца
    void add_befor(int, zveno*); // Метод для добавления элемента перед указанным элементом кольца
    void Delete(zveno*); // Метод для удаления указанного элемента кольца
    void delete_next(zveno*); // Метод для удаления элемента, следующего за указанным элементом кольца
    int poisk(int, zveno**); // Метод для поиска элемента кольца по значению
    zveno** getring() { return &ukring; }; // Метод для получения указателя на кольцо
};

// Метод для создания кольца
void ring::create()
{
    zveno* ukzv; // Указатель на текущий элемент кольца
    int elem; // Переменная для хранения вводимых элементов

    // Вывод сообщения о начале построения кольца
    cout << "\nПостроение кольца ..." << endl;
    cout << "Вводите элементы кольца (ввод окончите 0): \n";
    cout << "-->";
    cin >> elem; // Ввод первого элемента кольца

    // Если введённый элемент не равен 0
    if (elem != 0)
    {
        // Создание первого элемента кольца
        ukzv = ukring = new (zveno);
        (*ukzv).element = elem; // Присваивание введённого значения элементу кольца
        (*ukzv).ukTree.creat_Tree(); // Создание дерева для текущего элемента кольца
        cout << "\n-->";
        cin >> elem; // Ввод следующего элемента кольца

        // Пока вводимый элемент не равен 0
        while (elem != 0)
        {
            (*ukzv).sled = new (zveno); // Создание нового элемента кольца
            ukzv = (*ukzv).sled; // Переход к новому элементу кольца
            (*ukzv).element = elem; // Присваивание введённого значения элементу кольца
            (*ukzv).ukTree.creat_Tree(); // Создание дерева для текущего элемента кольца
            cout << "\n-->";
            cin >> elem; // Ввод следующего элемента кольца
        }
        ukzv->sled = ukring; // Замыкание кольца
    }
}


// Деструктор класса для работы с кольцом
ring::~ring()
{
    zveno* ukzv; // Указатель на текущий элемент кольца

    ukzv = ukring; // Начальное значение указателя - первый элемент кольца
    // Пока кольцо не опустеет
    while (ukring != NULL)
    {
        // Если текущий элемент является последним в кольце
        if (ukzv->sled == ukring)
        {
            ukring = NULL; // Присваиваем значение NULL указателю на кольцо, чтобы завершить цикл
            ukzv->ukTree.~Tree(); // Вызов деструктора для дерева текущего элемента кольца
            delete ukzv; // Освобождение памяти, выделенной под текущий элемент кольца
        }
        else
        {
            // Пока текущий элемент не предпоследний в кольце
            while (ukzv->sled->sled != ukring)
                ukzv = (*ukzv).sled; // Переход к следующему элементу кольца
            (*ukzv).sled->ukTree.~Tree(); // Вызов деструктора для дерева текущего элемента кольца
            delete (*ukzv).sled; // Освобождение памяти, выделенной под текущий элемент кольца
            ukzv->sled = ukring; // Замыкание кольца
            ukzv = ukring; // Переход к первому элементу кольца
        }
    }
}


void ring::look() // Вывод кольца.
{
    zveno* ukzv; // Указатель на текущий элемент кольца

    cout << "\nВывод содержимого кольца ...";
    ukzv = ukring; // Начальное значение указателя - первый элемент кольца
    do {
        cout << "\n-->" << (*ukzv).element << endl; // Вывод элемента кольца
        ukzv->ukTree.look_Tree(); // Вызов метода для просмотра дерева, связанного с текущим элементом кольца
        ukzv = ukzv->sled; // Переход к следующему элементу кольца
        _getch(); // Ожидание нажатия клавиши (зависит от среды выполнения)
    } while (ukzv != ukring); // Повторять, пока не вернемся к первому элементу кольца
    cout << endl;
}


void ring::add_befor(int elem, zveno* zv)
{
    zveno* ukzv; // Указатель на новое звено

    ukzv = new (zveno); // Создание нового звена

    // Сохранение информации о текущем звене во временную переменную
    Tree temp = ukzv->ukTree;
    ukzv->element = zv->element;
    ukzv->ukTree = zv->ukTree;
    ukzv->sled = zv->sled;

    zv->element = elem; // Замена элемента текущего звена
    zv->ukTree = temp; // Замена связанного дерева текущего звена
    zv->ukTree.creat_Tree(); // Создание нового дерева для текущего звена
    zv->sled = ukzv; // Установка указателя на новое звено
}

void ring::add_after(int elem, zveno* zv)
{
    zveno* ukzv; // Указатель на новое звено

    ukzv = new (zveno); // Создание нового звена
    ukzv->element = elem; // Установка значения элемента нового звена
    ukzv->ukTree.creat_Tree(); // Создание нового дерева для нового звена
    ukzv->sled = zv->sled; // Установка указателя на следующее звено для нового звена
    zv->sled = ukzv; // Установка указателя на новое звено для предыдущего звена
}

void ring::Delete(zveno* zv)
{
    zveno* ukzv1, * ukzv2; // Указатели на звено, предшествующее удаляемому, и на звено, следующее за удаляемым
    zveno* time; // Временный указатель на звено

    if (zv->sled != ukring) // Если удаляемое звено не является последним в кольце
    {
        time = zv->sled; // Запоминаем указатель на следующее за удаляемым звено
        zv->ukTree.~Tree(); // Уничтожаем дерево в удаляемом звене
        (*zv) = *((*zv).sled); // Копируем данные из следующего за удаляемым звена в удаляемое звено
        delete time; // Удаляем следующее за удаляемым звено
    }
    else if (zv->sled == zv) // Если кольцо состоит из одного звена
    {
        zv->ukTree.~Tree(); // Уничтожаем дерево в единственном звене кольца
        delete ukring; // Удаляем звено
        ukring = NULL; // Устанавливаем указатель на кольцо как NULL, так как кольцо теперь пусто
        cout << "Список пуст...\n"; // Выводим сообщение о том, что список пуст
    }
    else // Если удаляемое звено находится в середине кольца
    {
        ukzv2 = ukring; // Указатель ukzv2 на первое звено кольца
        ukzv1 = ukring->sled; // Указатель ukzv1 на второе звено кольца
        while (ukzv1 != zv) // Пока не найдено удаляемое звено
        {
            ukzv2 = ukzv1; // Перемещаем указатель ukzv2 на следующее звено
            ukzv1 = ukzv1->sled; // Перемещаем указатель ukzv1 на следующее звено
        }
        time = ukzv2->sled; // Запоминаем указатель на удаляемое звено
        ukzv2->sled->ukTree.~Tree(); // Уничтожаем дерево в удаляемом звене
        ukzv2->sled = ukzv2->sled->sled; // Пропускаем удаляемое звено при переходе от предыдущего к следующему
        delete time; // Удаляем удаляемое звено
    }
}

void ring::delete_next(zveno* zv)
{
    zveno* time; // Временный указатель на следующее за удаляемым звено

    if (zv->sled != ukring) // Если удаляемое звено не является последним в кольце
    {
        time = zv->sled; // Запоминаем указатель на следующее за удаляемым звено
        zv->sled = zv->sled->sled; // Пропускаем удаляемое звено при переходе от текущего к следующему
        time->ukTree.~Tree(); // Уничтожаем дерево в удаляемом звене
        delete time; // Удаляем следующее за удаляемым звено
    }
    else if (zv->sled == zv) // Если кольцо состоит только из одного звена
    {
        cout << "В кольце только один элемент!\n"; // Выводим сообщение о том, что в кольце только один элемент
    }
    else // Если удаляемое звено последнее в кольце
    {
        time = ukring->sled; // Запоминаем указатель на следующее после начального звена кольца
        *((*zv).sled) = (*(*(*zv).sled).sled); // Пропускаем удаляемое звено при переходе от текущего к следующему
        time->ukTree.~Tree(); // Уничтожаем дерево в удаляемом звене
        delete time; // Удаляем следующее за удаляемым звено
    }
}


int ring::poisk(int elem, zveno** Res)
{
    zveno* ukzv; // Указатель на текущее звено
    int vozvr = 0; // Флаг для указания наличия элемента в кольце

    if (*(getring()) == NULL) // Если кольцо не существует
    {
        cout << "Кольцо не существует...\n"; // Выводим сообщение об отсутствии кольца
    }
    else
    {
        ukzv = ukring; // Устанавливаем указатель на начальное звено кольца
        while (ukzv->sled != ukring && (*Res) == NULL) // Пока не вернулись к начальному звену и результат не найден
        {
            if (ukzv->element == elem) // Если текущий элемент равен искомому
            {
                vozvr = 1; // Устанавливаем флаг наличия элемента
                *Res = ukzv; // Сохраняем указатель на найденное звено
            }
            ukzv = ukzv->sled; // Переходим к следующему звену
        }
        if ((*Res) == NULL) // Если результат поиска не найден
        {
            if (ukzv->element == elem) // Проверяем последнее звено
            {
                vozvr = 1; // Устанавливаем флаг наличия элемента
                *Res = ukzv; // Сохраняем указатель на найденное звено
            }
        }
    }
    return vozvr; // Возвращаем флаг наличия элемента
}

Tree::~Tree()
{
    DisposeTree(root); // Вызываем функцию удаления всех узлов дерева, начиная с корня
    root = NULL; // Обнуляем указатель на корень
}

void Tree::DisposeTree(node* p)
{
    if (p != NULL) // Если узел не пустой
    {
        DisposeTree(p->Left); // Удаляем левое поддерево
        DisposeTree(p->Right); // Удаляем правое поддерево
        delete p; // Удаляем сам узел
    }
}

void Tree::search(int x, node** p)
{
    if (*p == NULL) // Если указатель на узел пустой
    {
        *p = new node; // Выделяем память под новый узел
        (**p).key = x; // Устанавливаем значение ключа
        (**p).count = 1; // Устанавливаем начальное значение счетчика
        (**p).Left = (**p).Right = NULL; // Обнуляем указатели на левое и правое поддерево
    }
    else if (x < (**p).key) // Если значение ключа меньше ключа текущего узла
    {
        search(x, &((**p).Left)); // Рекурсивно ищем в левом поддереве
    }
    else if (x > (**p).key) // Если значение ключа больше ключа текущего узла
    {
        search(x, &((**p).Right)); // Рекурсивно ищем в правом поддереве
    }
    else // Если значение ключа равно ключу текущего узла
    {
        (**p).count += 1; // Увеличиваем счетчик
    }
}

void Tree::creat_Tree()
{
    int elem;

    cout << "Вводите ключи узлов дерева (ввод окончите 0):\n"; // Выводим приглашение для ввода ключей
    cin >> elem; // Считываем первый ключ
    while (elem != 0) // Пока вводимый ключ не равен 0 (сигнал завершения ввода)
    {
        search(elem, &root); // Вызываем функцию поиска и вставки ключа в дерево
        cin >> elem; // Считываем следующий ключ
    }
}

void Tree::look_Tree()
{
    if (root == NULL)
        cout << "Дерево пусто ...\n"; // Выводим сообщение о том, что дерево пусто
    else
        printTree(root, 0); // Выводим содержимое дерева с корнем root
}

void Tree::printTree(node* w, int L)
{
    if (w != NULL)
    {
        printTree(w->Left, L + 1); // Рекурсивно выводим левое поддерево
        for (int i = 1; i <= L; i++)
            cout << "  "; // Выводим пробелы для отступа в зависимости от уровня узла
        cout << w->key << endl; // Выводим значение ключа узла
        printTree(w->Right, L + 1); // Рекурсивно выводим правое поддерево
    }
}

void Tree::add_Tree()
{
    int k;

    cout << "\nВводите ключи добавляемых узлов (ввод окончите 0):\n"; // Просим пользователя ввести ключи для добавления узлов
    cin >> k; // Считываем первый ключ
    cout << " ";
    while (k != 0)
    {
        search(k, &(root)); // Вызываем функцию поиска для добавления узла с ключом k
        cin >> k; // Считываем следующий ключ
        cout << " ";
    }
}

void Tree::delete_Tree()
{
    int elem;

    if (root == NULL) // Проверяем, пустое ли дерево
        cout << "Дерево пусто ...\n";
    else
    {
        cout << "Введите ключ удаляемого узла : "; // Просим пользователя ввести ключ удаляемого узла
        cin >> elem; // Считываем ключ удаляемого узла
        cout << endl;
        Delete(&root, elem); // Вызываем функцию удаления узла с заданным ключом
    }
}

void Tree::Delete(node** d, int k)
{
    node* q;
    node* s;

    if (*d == NULL) // Если указатель на узел пуст, выводим сообщение об ошибке
        cout << "Узел с заданным ключом в дереве не найден ...\n";
    else
    {
        if (k < (**d).key) // Если ключ для удаления меньше ключа текущего узла, вызываем функцию удаления для левого поддерева
            Delete(&((**d).Left), k);
        else if (k > (**d).key) // Если ключ для удаления больше ключа текущего узла, вызываем функцию удаления для правого поддерева
            Delete(&((**d).Right), k);
        else // Иначе, нашли узел с заданным ключом
        {
            q = *d;
            s = *d;
            if ((*q).Right == NULL) // Если у узла нет правого поддерева
            {
                *d = (*q).Left; // Заменяем текущий узел на его левый потомок
                delete s; // Удаляем текущий узел
            }
            else if ((*q).Left == NULL) // Если у узла нет левого поддерева
            {
                *d = (*q).Right; // Заменяем текущий узел на его правый потомок
                delete s; // Удаляем текущий узел
            }
            else // Если у узла есть оба потомка
                del(&((*q).Left), &(*q)); // Вызываем функцию del для нахождения узла для замены
        }
    }
}

void Tree::del(node** r, node* q)
{
    node* s;

    if ((**r).Right == NULL) // Если у правого потомка нет правого поддерева
    {
        (*q).key = (**r).key; // Копируем ключ правого потомка в узел q
        (*q).count = (**r).count; // Копируем количество вхождений правого потомка в узел q
        q = s = *r; // Присваиваем указателям q и s адрес правого потомка
        *r = (**r).Left; // Заменяем правого потомка на его левого потомка
        delete s; // Удаляем правого потомка
    }
    else
        del(&((**r).Right), &(*q)); // Рекурсивно вызываем функцию del для правого поддерева
}

void main()
{
    setlocale(LC_ALL, "Rus"); // Устанавливаем локаль на русский для корректного отображения текста.
    int menu1 = 1, choice, elem1, elem2, menu2; // Объявляем переменные для выбора в меню и значений элементов.
    ring A; // Создаем экземпляр класса ring.
    zveno* Res; // Объявляем указатель на объект zveno.

    cout << "<------------- Структура --------------->\n"; // Выводим заголовок структуры.
    cout << "<---------\"кольцо с деревьями\"---------->\n\n"; // Выводим подзаголовок структуры.

    while (menu1) // Начинаем основной цикл меню.
    {
        cout << endl;
        cout << "<---------- Главное меню 1.0 : --------->\n"; // Выводим заголовок главного меню.
        cout << "1. Построение структуры.................. \n"; // Выводим пункты меню.
        cout << "2. Просмотр структуры.................... \n";
        cout << "3. Добавление элемента после указанного.. \n";
        cout << "4. Добавление элемента перед указанным... \n";
        cout << "5. Удаление элемента..................... \n";
        cout << "6. Удаление элемента после указанного.... \n";
        cout << "7. Преобразование дерева заданного эл-та. \n";
        cout << "8. Удаление структуры.................... \n";
        cout << "9. Выход................................. \n";
        cout << "Введите номер режима и нажмите <Enter> : "; // Просим пользователя выбрать пункт меню.
        cin >> choice; cout << endl; // Считываем выбор пользователя.

        switch (choice) // Начинаем оператор выбора в зависимости от выбора пользователя.
        {
        case 1: // Если выбран пункт 1, выполняем создание структуры.
            if (*(A.getring()) == NULL) A.create(); // Проверяем, пустое ли кольцо, затем создаем его.
            else  cout << "Кольцо уже существует...\n"; // Если не пустое, выводим сообщение.
            break;

        case 2: // Если выбран пункт 2, выполняем просмотр структуры.
            if (*(A.getring()) == NULL) cout << "Кольцо пусто...\n"; // Проверяем, пустое ли кольцо, затем выводим сообщение.
            else  A.look(); // Если не пустое, выводим содержимое кольца.
            break;

        case 3: // Если выбран пункт 3, выполняем добавление элемента после указанного элемента.
            if (*(A.getring()) == NULL) cout << "Кольцо пусто...\n"; // Проверяем, пустое ли кольцо, затем выводим сообщение.
            else // Если не пустое, выполняем добавление элемента после указанного элемента.
            {
                Res = NULL; // Инициализируем указатель нулем.
                cout << "Введите элемент, после которого ";
                cout << " хотите добавить звено: ";
                cin >> elem1; cout << endl;
                if (A.poisk(elem1, &Res))
                {
                    cout << "Введите элемент, который ";
                    cout << "хотите  добавить: ";
                    cin >> elem2;
                    cout << endl;
                    A.add_after(elem2, Res);
                }
                else
                    cout << "Элемент " << elem1 << " не найден.\n";
            }
            break;

        case 4: // Если выбран пункт 4, выполняем добавление элемента перед указанным элементом.
            if (*(A.getring()) == NULL) cout << "Кольцо пусто...\n"; // Проверяем, пустое ли кольцо, затем выводим сообщение.
            else // Если не пустое, выполняем добавление элемента перед указанным элементом.
            {
                Res = NULL; // Инициализируем указатель нулем.
                cout << "Введите элемент, перед которым ";
                cout << " хотите добавить звено: ";
                cin >> elem1; cout << endl;
                if (A.poisk(elem1, &Res))
                {
                    cout << "Введите элемент, который ";
                    cout << "хотите  добавить: ";
                    cin >> elem2;
                    cout << endl;
                    A.add_befor(elem2, Res);
                }
                else
                    cout << "Элемент " << elem1 << " не найден.\n";
            }
            break;

        case 5: // Если выбран пункт 5, выполняем удаление указанного элемента.
            if (*(A.getring()) == NULL) cout << "Кольцо пусто...\n"; // Проверяем, пустое ли кольцо, затем выводим сообщение.
            else // Если не пустое, выполняем удаление указанного элемента.
            {
                Res = NULL; // Инициализируем указатель нулем.
                cout << "Введите элемент, который";
                cout << " хотите удалить: ";
                cin >> elem1; cout << endl;
                if (A.poisk(elem1, &Res)) A.Delete(Res);
                else  cout << "Элемент отсутствует...\n";
            }
            break;

        case 6: // Если выбран пункт 6, выполняем удаление элемента после указанного элемента.
            if (*(A.getring()) == NULL) cout << "Кольцо пусто...\n"; // Проверяем, пустое ли кольцо, затем выводим сообщение.
            else // Если не пустое, выполняем удаление элемента после указанного элемента.
            {
                Res = NULL; // Инициализируем указатель нулем.
                cout << "Введите элемент, после которого";
                cout << " хотите удалить: ";
                cin >> elem1; cout << endl;
                if (A.poisk(elem1, &Res)) A.delete_next(Res);
                else  cout << "Элемент отсутствует...\n";
            }
            break;

        case 7: // Если выбран пункт 7, выполняем преобразование дерева заданного элемента.
            if (*(A.getring()) == NULL) cout << "Кольцо пусто...\n"; // Проверяем, пустое ли кольцо, затем выводим сообщение.
            else // Если не пустое, выполняем преобразование дерева заданного элемента.
            {
                Res = NULL; // Инициализируем указатель нулем.
                cout << "Введите элемент кольца: ";
                cin >> elem1; cout << endl;
                if (A.poisk(elem1, &Res))
                {
                    menu2 = 1;
                    while (menu2)
                    {
                        cout << endl;
                        cout << "<---------- Mеню 1.1 : --------->\n";
                        cout << "1. Построение дерева.............\n";
                        cout << "2. Просмотр дерева...............\n";
                        cout << "3. Добавление элемента в дерево..\n";
                        cout << "4. Удаление элемента из дерева...\n";
                        cout << "5. Удаление дерева...............\n";
                        cout << "6. Выход в главное меню..........\n";
                        cout << "Введите номер режима и нажмите <Enter>: ";
                        cin >> choice; cout << endl;
                        switch (choice)
                        {
                        case 1: // Если выбран пункт 1, выполняем создание дерева.
                            if ((*Res).ukTree.getTree() == NULL)
                                (*Res).ukTree.creat_Tree();
                            else  cout << "Дерево существует...\n";
                            break;
                        case 2: (*Res).ukTree.look_Tree(); break; // Если выбран пункт 2, выполняем просмотр дерева.
                        case 3: (*Res).ukTree.add_Tree(); break; // Если выбран пункт 3, выполняем добавление элемента в дерево.
                        case 4: (*Res).ukTree.delete_Tree(); break; // Если выбран пункт 4, выполняем удаление элемента из дерева.
                        case 5: // Если выбран пункт 5, выполняем удаление дерева.
                            if ((*Res).ukTree.getTree() == NULL)
                                cout << "Дерево не существует...\n";
                            else  (*Res).ukTree.~Tree();
                            break;
                        case 6: menu2 = 0; break; // Если выбран пункт 6, выходим из подменю.
                        }
                    }
                }
                else  cout << "Элемент " << elem1 << " не найден.\n";
            }
            break;

        case 8: // Если выбран пункт 8, выполняем удаление структуры.
            if (*(A.getring()) == NULL) cout << "Кольцо пусто...\n"; // Проверяем, пустое ли кольцо, затем выводим сообщение.
            else A.~ring(); // Если не пустое, выполняем удаление структуры.
            break;

        case 9: // Если выбран пункт 9, завершаем работу программы.
            A.~ring(); // Удаляем кольцо.
            menu1 = 0; // Выходим из цикла основного меню.
            break;
        } // Конец оператора выбора
    } // Конец while

    cout << "\n";
    system("PAUSE"); // Приостанавливаем выполнение программы.
}
