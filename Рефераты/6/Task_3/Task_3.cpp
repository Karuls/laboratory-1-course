#include <time.h> // Подключаем заголовочный файл для работы с временем
#include <iostream> 
using namespace std; 

#define N 10 // Определяем константу для количества элементов массива

struct node // Определяем структуру узла бинарного дерева
{
	int Key; // Ключ узла
	int Count; // Счетчик повторений ключа
	node* Left; // Указатель на левого потомка
	node* Right; // Указатель на правого потомка
};

class Spisok // Определяем класс для работы с хэш-списком
{
private:
	node* UkStr[N]; // Массив указателей на корни бинарных деревьев
	void Search(int, node**); // Объявление функции для поиска узла в дереве
	void PrintTree(node*, int); // Объявление функции для вывода дерева на экран
	void U_d(node**, node**); // Объявление функции для удаления узла из дерева
public:
	Spisok(); // Конструктор класса
	void BuildTree(); // Метод для построения хэш-списка
	void Sodergimoe(); // Метод для вывода содержимого хэш-списка
	node** GetTree(unsigned i) { return &(UkStr[i]); } // Метод для получения указателя на корень i-го дерева
	void Udaldr(node** d, int k); // Метод для удаления узла с ключом k из дерева d
};

Spisok::Spisok()
{
	// Инициализация хэш-списка.
	for (int i = 0; i < N; i++) UkStr[i] = NULL; // Устанавливаем все указатели в массиве в NULL
}

void Spisok::BuildTree()
{
	int klutch; // Переменная для ключа
	unsigned hash; // Переменная для хэша

	srand(time(0)); // Инициализируем генератор случайных чисел
	cout << "\nВведите значение ключа..."; 
	klutch = rand() % 31 + 0; // Генерируем случайный ключ в диапазоне от 0 до 31
	cout << klutch; // Выводим сгенерированный ключ
	while (klutch != 0) // Пока ключ не равен 0
	{
		hash = klutch % 10; // Вычисляем значение хэш-функции
		Search(klutch, &UkStr[hash]); // Вызываем метод поиска и вставки узла в дерево
		cout << "\nВведите значение ключа...";
		klutch = rand() % 31 + 0; // Генерируем новый случайный ключ
		cout << klutch; // Выводим сгенерированный ключ
	}
}

void Spisok::Search(int X, node** p)
{
	if (*p == NULL)
	{ // Узла нет в дереве; включаем его.
		*p = new (node); // Выделяем память под новый узел
		(**p).Key = X; // Присваиваем значение ключа
		(**p).Count = 1; // Устанавливаем счетчик повторений ключа в 1
		(**p).Left = (**p).Right = NULL; // Инициализируем указатели на потомков как NULL
	}
	else
		if (X < (**p).Key) Search(X, &((**p).Left)); // Если ключ меньше текущего, идем влево
		else if (X > (**p).Key)  Search(X, &((**p).Right)); // Если ключ больше текущего, идем вправо
		else  (**p).Count += 1; // Иначе увеличиваем счетчик повторений ключа
}

void Spisok::Sodergimoe()
{
	for (int i = 0; i < N; i++) // Проходим по всем деревьям хэш-списка
	{
		cout << "  " << i << "...  "; // Выводим номер дерева
		if (UkStr[i] == NULL)  cout << "Дерево пусто...\n"; // Если дерево пустое, выводим сообщение
		else // Иначе
		{
			cout << endl; // Переход на новую строку
			PrintTree(UkStr[i], 0); // Вызываем метод для вывода дерева на экран
		}
		cout << "------------------------------------------" << endl; 
	}
}

void Spisok::PrintTree(node* w, int l)
{
	if (w != NULL)
	{
		PrintTree((*w).Right, l + 1); // Рекурсивно выводим правое поддерево
		cout << "          "; // Выводим отступ
		for (int i = 1; i <= l; i++) cout << "   "; // Выводим отступы в зависимости от уровня узла
		cout << (*w).Key << endl; // Выводим ключ узла
		PrintTree((*w).Left, l + 1); // Рекурсивно выводим левое поддерево
	}
}

void Spisok::Udaldr(node** d, int k)
{ // Удаление узла с ключом k из дерева d.
	node** q;

	if (*d == NULL) cout << "Узел с заданным ключом в дереве не найден...\n"; // Если дерево пустое
	else
		if (k < (**d).Key) Udaldr(&((**d).Left), k); // Если ключ меньше текущего, идем влево
		else if (k > (**d).Key)  Udaldr(&((**d).Right), k); // Если ключ больше текущего, идем вправо
		else // Иначе нашли узел для удаления
		{
			q = d; // Сохраняем указатель на удаляемый узел
			if ((**q).Right == NULL) *d = (**q).Left; // Если у удаляемого узла нет правого потомка
			else
				if ((**q).Left == NULL)  *d = (**q).Right; // Если у удаляемого узла нет левого потомка
				else  U_d(&((**q).Left), &(*q)); // Если у удаляемого узла есть оба потомка, вызываем функцию удаления
		}
}

void Spisok::U_d(node** r, node** q)
{
	if ((**r).Right == NULL)
	{
		(**q).Key = (**r).Key; // Копируем ключ из правого поддерева вместо удаляемого
		(**q).Count = (**r).Count; // Копируем счетчик из правого поддерева вместо удаляемого
		q = r; *r = (**r).Left; delete (*q); // Удаляем правое поддерево и переходим к левому
	}
	else  U_d(&((**r).Right), &(*q)); // Рекурсивно продолжаем искать крайний левый узел в правом поддереве
}

void main()
{
	setlocale(LC_ALL, "Rus"); // Устанавливаем русскую локаль
	Spisok A; // Создаем объект класса Spisok

	A.BuildTree(); // Вызываем метод для построения хэш-списка
	cout << "\n          Содержимое хэш-списка..."; 
	cout << "\n    -----------------------------------\n"; 
	A.Sodergimoe(); // Выводим содержимое хэш-списка

	// Удаление элемента из хэш-списка.
	for (int i = 0; i < 4; i++) // Будем удалять всего 4 раза!
	{
		cout << "\nВведите значение удаляемого ключа..."; 
		int klutch; // Переменная для ключа
		cin >> klutch; // Вводим значение ключа для удаления
		unsigned hash = klutch % 10; // Вычисляем значение хэша для данного ключа
		A.Udaldr(A.GetTree(hash), klutch); // Вызываем метод для удаления узла с заданным ключом из хэш-списка
		cout << "          Содержимое хэш-списка...\n"; 
		cout << "   ----------------------------------\n";
		A.Sodergimoe(); // Выводим содержимое хэш-списка после удаления
	}

	cout << "\n"; 
	system("PAUSE");
}
