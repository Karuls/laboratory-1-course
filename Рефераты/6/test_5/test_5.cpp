#include <stdio.h>
#include <conio.h>
#include <iostream>
using namespace std;

// Структура для представления звена в дереве Хаффмана
struct zveno
{
    char Element; // Символ
    float  Kol;   // Количество повторений, частота повторений
    zveno* Sled;  // Указатель на следующее звено в списке
    zveno* Left;  // Указатель на левое поддерево
    zveno* Right; // Указатель на правое поддерево
    zveno* Father; // Указатель на родителя
};

// Класс для работы с деревом Хаффмана
class Tree
{
private:
    zveno* UkStr; // Указатель на список
    int Poisk1(zveno**, float, zveno**); // Вспомогательная функция поиска места в упорядоченном списке
public:
    Tree() { UkStr = new (zveno); UkStr->Sled = NULL; }; // Конструктор
    int Poisk(char, zveno**); // Поиск элемента в списке
    int Kolich(char*, char); // Подсчет количества повторений символа в тексте
    void Dobavlenie(char, float, zveno**); // Добавление звена в список
    void Redaktor(int); // Изменение поля Kol на частоту повторений
    void Ukazateli(zveno**, zveno**); // Поиск указателей на предпоследний и предпредпоследний элементы
    void Vyvod(); // Вывод списка на экран
    void WstawkaSort(zveno*); // Вставка элемента в упорядоченный список
    void PrintTree(zveno*, int); // Печать дерева
    zveno** GetTree() { return &UkStr; }; // Получение указателя на список
    zveno* GetTree1() { return UkStr; }; // Получение списка
};

// Метод для поиска элемента в списке по символу
int Tree::Poisk(char ENT, zveno** Res)
{
    zveno* q; // Указатель на текущее звено списка
    int vozvr = 0; // Переменная для возврата результата поиска (1 - если найдено, 0 - если не найдено)

    *Res = NULL; // Инициализация указателя на найденный элемент
    q = (*UkStr).Sled; // Установка указателя на первый элемент списка (после заглавного звена)
    // Проход по списку
    while (q != NULL && *Res == NULL)
    {
        // Проверка, содержит ли текущее звено искомый символ
        if (q->Element == ENT)
        {
            vozvr = 1; // Устанавливаем результат поиска в "найдено"
            *Res = q; // Сохраняем указатель на найденное звено
            return vozvr; // Возвращаем результат поиска
        }
        q = q->Sled; // Переходим к следующему звену списка
    }
    return vozvr; // Возвращаем результат поиска
}

// Метод для поиска места в упорядоченном списке для добавления элемента
int Tree::Poisk1(zveno** st, float kol, zveno** Res)
{
    zveno* q = (**st).Sled, * q1 = (*st); // Указатели на текущее и предыдущее звено
    int vozvr = 0; // Переменная для возврата результата поиска (1 - если найдено место для вставки, 0 - если не найдено)

    *Res = NULL; // Инициализация указателя на место для вставки
    // Проход по списку
    while (q != NULL && *Res == NULL)
    {
        // Проверка условия для вставки элемента (если текущий элемент имеет меньшее значение Kol)
        if (q->Kol < kol)
        {
            vozvr = 1; // Устанавливаем результат поиска в "найдено место для вставки"
            *Res = q; // Сохраняем указатель на место для вставки
        }
        q = q->Sled; // Переходим к следующему звену списка
        q1 = q1->Sled; // Переходим к следующему звену списка (для обновления указателя на предыдущее звено)
    }
    if (*Res == NULL)
        *Res = q1; // Если место для вставки не было найдено, устанавливаем указатель на последнее звено
    return vozvr; // Возвращаем результат поиска
}

// Метод для подсчета количества повторений символа в тексте
int Tree::Kolich(char* F, char S)
{
    int K = 0; // Переменная для хранения количества повторений символа

    // Проход по тексту
    for (int i = 0; i < strlen(F); i++)
        // Проверка, содержит ли текущий символ искомый символ
        if (F[i] == S)
            K++; // Увеличиваем счетчик повторений
    return K; // Возвращаем количество повторений
}

// Метод для изменения поля Kol на частоту повторений
void Tree::Redaktor(int L)
{
    zveno* q = (*UkStr).Sled; // Указатель на текущее звено списка

    // Проход по списку
    while (q != NULL)
    {
        q->Kol = q->Kol / L; // Изменяем значение поля Kol на частоту повторений
        q = q->Sled; // Переходим к следующему звену списка
    }
}

// Метод для добавления звена в список, упорядоченный по количеству повторений
void Tree::Dobavlenie(char bukva, float kol, zveno** Sp)
{
    zveno* q, * Res = NULL, * kladovaq; // Объявление указателей на звено и вспомогательные переменные

    q = new (zveno); // Создание нового звена
    q->Element = bukva; // Установка символа в звене
    q->Kol = kol; // Установка количества повторений символа в звене
    q->Left = q->Right = NULL; // Установка указателей на левое и правое поддерево в NULL
    q->Sled = q->Father = NULL; // Установка указателей на следующее звено и на родителя в NULL

    // Если список пуст
    if ((**Sp).Sled == NULL)
        (**Sp).Sled = q; // Устанавливаем новое звено как первое в списке
    else
        // Если в списке уже есть элементы
        if (Poisk1(&(*Sp), kol, &Res)) // Поиск места для вставки нового звена
        {
            kladovaq = new (zveno); // Создание нового звена для хранения ссылки на следующее звено
            (*kladovaq) = (*Res); // Копирование значений звена Res в новое звено kladovaq
            (*Res) = (*q); // Замена звена Res на новое звено q
            Res->Sled = kladovaq; // Установка ссылки на следующее звено
        }
        else
            Res->Sled = q; // Простое добавление звена в конец списка
}

// Метод для поиска указателей на предпоследний и предпредпоследний элементы
void Tree::Ukazateli(zveno** zv, zveno** zv_p)
{
    *zv_p = UkStr->Sled; // Устанавливаем указатель на первый элемент списка
    *zv = UkStr; // Устанавливаем указатель на заглавное звено
    // Пока у предпоследнего звена есть следующее звено
    while ((*zv_p)->Sled->Sled != NULL)
    {
        *zv = *zv_p; // Перемещаем указатель на текущее звено
        *zv_p = (*zv_p)->Sled; // Перемещаем указатель на следующее звено
    }
}


void Tree::Vyvod()
{
    zveno* q = UkStr->Sled; // Устанавливаем указатель на первый элемент списка

    while (q != NULL)
    {
        cout << q->Element << " (" << q->Kol << ") --> "; // Выводим символ и количество повторений этого символа
        q = q->Sled; // Переходим к следующему звену списка
    }
    cout << endl; // Печатаем новую строку для завершения вывода списка
}




void Tree::WstawkaSort(zveno* zv)
{
    zveno* w1, * w2; // Указатели на текущее и предыдущее звено

    w2 = UkStr; // Устанавливаем указатель w2 на заглавное звено
    w1 = w2->Sled; // Устанавливаем указатель w1 на первый элемент списка
    // Пока не достигнут конец списка и количества повторений текущего элемента больше чем у вставляемого
    while (w1 != NULL && w1->Kol > zv->Kol)
    {
        w2 = w1; // Перемещаем указатель w2 на следующий элемент списка
        w1 = w2->Sled; // Перемещаем указатель w1 на следующий элемент списка
    }
    // Если достигнут конец списка или количество повторений текущего элемента меньше или равно количеству повторений вставляемого элемента
    if (w1 == NULL || w1->Kol <= zv->Kol)
    {
        w2->Sled = zv; // Вставляем новое звено после предыдущего звена
        zv->Sled = w1; // Устанавливаем связь между новым звеном и следующим звеном списка
    }
}

void Tree::PrintTree(zveno* w, int l)
{
    // Проверяем, не является ли текущее звено пустым
    if (w != NULL)
    {
        // Рекурсивно вызываем функцию для правого поддерева с увеличением уровня на 1
        PrintTree(w->Right, l + 1);
        // Выводим отступы для текущего уровня
        for (int i = 1; i <= l; i++)
            cout << "   ";
        // Выводим символ и количество повторений этого символа
        cout << w->Element << " (" << w->Kol << ")\n";
        // Рекурсивно вызываем функцию для левого поддерева с увеличением уровня на 1
        PrintTree(w->Left, l + 1);
    }
}



void main()
{
    setlocale(LC_ALL, "Rus"); 
    Tree A; // Создание объекта класса Tree с именем A.
    char T[255]; // Исходная строка.
    int i, j; // Переменные для циклов.
    zveno* Res = NULL; // Указатель на результат.
    zveno* Q[256]; // Массив указателей на элементы списка.

    cout << "Введите текст, содержащий не менее двух символов...\n"; 
    gets_s(T); // Получение текста от пользователя.

    // Формирование списка, содержащего символы текста.
    for (i = 0; i < strlen(T); i++)
    {
        if (!A.Poisk(T[i], &Res)) // Если символ еще не встречался в списке.
            A.Dobavlenie(T[i], A.Kolich(T, T[i]), A.GetTree()); // Добавляем символ в список.
    }
    // ------------------------------- //
    A.Redaktor(strlen(T)); // Замена количества повторений символов на частоту повторений.
    cout << "Полученный список:\n"; // Вывод сообщения о полученном списке.
    A.Vyvod(); // Вывод списка на экран.
    // Заполнение массива Q указателями на элементы списка.
    zveno* UkZv = A.GetTree1()->Sled, * UkZv_p = NULL, * Sli; // Инициализация указателей на элементы списка.
    i = 0; // Счетчик.
    while (UkZv != NULL)
    {
        Q[i] = UkZv; // Заполнение массива указателями на элементы списка.
        i++; // Увеличение счетчика.
        UkZv = UkZv->Sled; // Переход к следующему элементу списка.
    }
    // Построение дерева Хаффмана.
    while (A.GetTree1()->Sled->Sled != NULL)
    {
        A.Ukazateli(&UkZv, &UkZv_p); // Поиск указателей на последний и предпоследний элементы списка.
        // Слияние последнего и предпоследнего звеньев.
        Sli = new (zveno);
        Sli->Element = '*'; // Обозначение слияния звеньев.
        Sli->Kol = UkZv_p->Kol + UkZv_p->Sled->Kol; // Вычисление суммарного количества повторений.
        Sli->Left = UkZv_p; // Левое поддерево - предпоследний элемент списка.
        Sli->Right = UkZv_p->Sled; // Правое поддерево - последний элемент списка.
        Sli->Father = Sli->Sled = NULL; // Инициализация указателей.
        UkZv_p->Father = Sli; // Установка указателя на отец для предпоследнего элемента.
        UkZv_p->Sled->Father = Sli; // Установка указателя на отец для последнего элемента.
        UkZv->Sled = NULL; // Удаление ссылки на последний элемент списка.
        UkZv_p->Sled = NULL; // Удаление ссылки на предпоследний элемент списка.
        // Добавление нового звена в список.
        if (A.GetTree1()->Sled == NULL)
            A.GetTree1()->Sled = Sli; // Если список пустой.
        else
            A.WstawkaSort(Sli); // Если список не пустой, вставляем новое звено с сортировкой.
    }
    cout << "Построим дерево...\n"; // Вывод сообщения о построении дерева.
    A.PrintTree(A.GetTree1()->Sled, 0); // Вывод дерева на экран.
    cout << "--------------------------------------------- " << endl; // Разделительная строка.
    // Кодирование введенного текста.
    cout << "Приступим к кодировке введенного текста...\n"; // Вывод сообщения о начале кодирования.
    char Cod_symbol[40]; // Буфер для кода символа.
    char Cod_Haffmen[255]; // Код Хаффмана строки T.
    char temp[255]; // Временный буфер для конкатенации строк.
    strcpy_s(Cod_symbol, ""); // Очистка буфера для кода символа.
    strcpy_s(Cod_Haffmen, ""); // Очистка буфера для кода Хаффмана.
    for (i = 0; i < strlen(T); i++)
    {
        // Начинаем поиск нужного указателя.
        j = 0;
        while (Q[j]->Element != T[i])
            j++; // Поиск указателя на символ в списке.
        // А теперь начинаем "восхождение"...
        UkZv = Q[j]; // Установка указателя на нужный элемент списка.
        while (UkZv->Father != NULL)
        {
            if (UkZv->Father->Left == UkZv)
            {
                strcpy_s(temp, "1"); // Если текущий элемент является левым потомком, добавляем "1" в код символа.
                strcat_s(temp, Cod_symbol); // Добавление текущего кода символа во временный буфер.
                strcpy_s(Cod_symbol, temp); // Обновление кода символа.
                UkZv = UkZv->Father; // Переход к отцу.
            }
            else
            {
                strcpy_s(temp, "0"); // Если текущий элемент является правым потомком, добавляем "0" в код символа.
                strcat_s(temp, Cod_symbol); // Добавление текущего кода символа во временный буфер.
                strcpy_s(Cod_symbol, temp); // Обновление кода символа.
                UkZv = UkZv->Father; // Переход к отцу.
            }
        }
        strcat_s(Cod_Haffmen, Cod_symbol); // Добавление кода символа в код Хаффмана.
        strcpy_s(Cod_symbol, ""); // Очистка буфера для кода символа.
    }
    cout << "Код перед Вами... " << Cod_Haffmen << endl; // Вывод кода Хаффмана.
    cout << "Коэффициент сжатия: " << 100 * strlen(Cod_Haffmen) / 8.0 / strlen(T) << "%\n"; // Рассчет и вывод коэффициента сжатия.
    // Расшифровка закодированного сообщения.
    cout << "Ранее было зашифровано... " << T << endl; // Вывод оригинальной строки.
    strcpy_s(T, ""); // Очистка строки для расшифровки.
    // Установим указатель на корень дерева.
    UkZv = A.GetTree1()->Sled; // Установка указателя на корень дерева.
    i = 0; // Счетчик.
    while (i < strlen(Cod_Haffmen))
    {
        while (UkZv->Left != NULL && UkZv->Right != NULL)
        {
            if (Cod_Haffmen[i] == '1')
                UkZv = UkZv->Left; // Если встречается "1", двигаемся влево.
            else
                UkZv = UkZv->Right; // Если встречается "0", двигаемся вправо.
            i++; // Увеличиваем счетчик.
        }
        char s[2];
        s[0] = UkZv->Element;
        s[1] = '\0'; // Завершаем строку нулем.
        strcat_s(T, s); // Добавляем символ к расшифрованной строке.
        UkZv = A.GetTree1()->Sled; // Возвращаемся к корню дерева.
    }
    cout << "Расшифровано..." << T << endl; // Вывод расшифрованной строки.

    cout << "\n";
    system("PAUSE"); // Ожидание нажатия клавиши для завершения программы.
}
