#include <iostream> // Подключение стандартной библиотеки ввода/вывода
using namespace std; // Использование пространства имен std

struct node // Определение структуры "node" для узлов бинарного дерева
{
    int Key; // Ключ узла
    int Count; // Счетчик повторений ключа
    node* Left; // Указатель на левого потомка
    node* Right; // Указатель на правого потомка
};

class TREE // Определение класса "TREE" для работы с бинарным деревом
{
private:
    node* Tree; // Указатель на корень дерева
    void Search(int, node**); // Прототип функции для поиска и вставки вершины в дерево
public:
    TREE() { Tree = NULL; } // Конструктор класса, инициализирующий корень дерева как NULL
    node** GetTree() { return &Tree; } // Метод для получения указателя на корень дерева
    void BuildTree(); // Метод для построения дерева
    void CleanTree(node**); // Метод для очистки дерева от памяти
    void ObhodEnd(node**); // Метод для концевого обхода дерев
    void ObhodLeft(node**); // Метод для левостороннего обхода дерева
    void ObhodBack(node**); // Метод для обратного обхода дерева
    void Vyvod(node**, int); // Метод для вывода дерева на экран
    int Height(node**); // Метод для определения высоты бинарного дерева
};

void main() // Главная функция программы
{
    setlocale(LC_ALL, "Rus"); // Установка локали для корректного отображения русского текста
    TREE A; // Создание объекта класса TREE

    A.BuildTree(); // Вызов метода для построения дерева
    cout << "\nВывод дерева:\n";
    A.Vyvod(A.GetTree(), 0); // Вызов метода для вывода дерева на экран
    cout << "\nВысота дерева:" << A.Height(A.GetTree()) << endl; // Вывод высоты дерева
    cout << "\nЛевосторонний обход дерева: ";
    A.ObhodLeft(A.GetTree()); // Вызов метода для левостороннего обхода дерева
    cout << "\nКонцевой обход дерева: "; A.ObhodEnd(A.GetTree()); // Вызов метода для концевого обхода дерева
    cout << "\nОбратный обход дерева: "; A.ObhodBack(A.GetTree()); // Вызов метода для обратного обхода дерева
    A.CleanTree(A.GetTree()); // Вызов метода для очистки дерева.

    cout << "\n";
    system("PAUSE"); // Пауза перед завершением программы
}

void TREE::BuildTree() // Метод для построения бинарного дерева
{
    int el; // Переменная для хранения вводимых ключей

    cout << "Вводите ключи вершин дерева ...\n"; 
    cin >> el; // Считывание первого ключа
    while (el != 0) // Пока не введен нулевой ключ (завершающий ввод)
    {
        Search(el, &Tree); // Вызов метода поиска и вставки вершины в дерево.
        cin >> el; // Считывание следующего ключа.
    }
}

void TREE::Search(int x, node** p) // Метод для поиска вершины с ключом x в дереве со вставкой.
{
    if (*p == NULL) // Если указатель на текущую вершину NULL (дошли до конца ветви).
    {
        *p = new(node); // Создаем новую вершину.
        (**p).Key = x; // Присваиваем ключ вершине.
        (**p).Count = 1; // Устанавливаем счетчик повторений ключа.
        (**p).Left = NULL; (**p).Right = NULL; // Инициализируем указатели на потомков как NULL.
    }
    else
        if (x < (**p).Key) Search(x, &((**p).Left)); // Если ключ меньше текущего, идем влево.
        else
            if (x > (**p).Key) Search(x, &((**p).Right)); // Если ключ больше текущего, идем вправо.
            else  (**p).Count = (**p).Count + 1; // Если ключ равен текущему, увеличиваем счетчик повторений.
}

void TREE::ObhodLeft(node** w) // Метод для левостороннего обхода дерева.
{
    if (*w != NULL) // Если текущая вершина не пуста.
    {
        cout << (**w).Key << " "; // Выводим ключ текущей вершины.
        ObhodLeft(&((**w).Left)); // Рекурсивно обходим левое поддерево.
        ObhodLeft(&((**w).Right)); // Рекурсивно обходим правое поддерево.
    }
}

void TREE::ObhodEnd(node** w) // Метод для концевого обхода дерева.
{
    if (*w != NULL) // Если текущая вершина не пуста.
    {
        ObhodEnd(&((**w).Left)); // Рекурсивно обходим левое поддерево.
        ObhodEnd(&((**w).Right)); // Рекурсивно обходим правое поддерево.
        cout << (**w).Key << " "; // Выводим ключ текущей вершины.
    }
}

void TREE::ObhodBack(node** w) // Метод для обратного обхода дерева.
{
    if (*w != NULL) // Если текущая вершина не пуста.
    {
        ObhodBack(&((**w).Left)); // Рекурсивно обходим левое поддерево.
        cout << (**w).Key << " "; // Выводим ключ текущей вершины.
        ObhodBack(&((**w).Right)); // Рекурсивно обходим правое поддерево.
    }
}

void TREE::CleanTree(node** w) // Метод для очистки дерева от памяти.
{
    if (*w != NULL) // Если текущая вершина не пуста.
    {
        CleanTree(&((**w).Left)); // Рекурсивно очищаем левое поддерево.
        CleanTree(&((**w).Right)); // Рекурсивно очищаем правое поддерево.
        delete* w; // Удаляем текущую вершину.
    }
}

void TREE::Vyvod(node** w, int l) // Метод для вывода дерева на экран.
{
    int i; // Переменная для цикла.

    if (*w != NULL) // Если текущая вершина не пуста.
    {
        Vyvod(&((**w).Right), l + 1); // Рекурсивно выводим правое поддерево.
        for (i = 1; i <= l; i++) cout << "   "; // Отступ для текущей вершины.
        cout << (**w).Key << endl; // Выводим ключ текущей вершины.
        Vyvod(&((**w).Left), l + 1); // Рекурсивно выводим левое поддерево.
    }
}

int TREE::Height(node** w) // Метод для определения высоты бинарного дерева.
{
    int h1, h2; // Переменные для хранения высот левого и правого поддеревьев.

    if (*w == NULL) return (-1); // Если текущая вершина пуста, возвращаем -1 (высота пустого дерева).
    else
    {
        h1 = Height(&((**w).Left)); // Рекурсивно определяем высоту левого поддерева.
        h2 = Height(&((**w).Right)); // Рекурсивно определяем высоту правого поддерева.
        if (h1 > h2) return (1 + h1); // Возвращаем большую из высот поддеревьев.
        else  return (1 + h2);
    }
}
