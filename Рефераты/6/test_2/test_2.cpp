#include <iostream> 
using namespace std; 

struct node // Определяем структуру узла бинарного дерева
{
    int Key; // Ключ узла
    int Count; // Счетчик повторений ключа
    node* Left; // Указатель на левого потомка
    node* Right; // Указатель на правого потомка
};

struct no // Звено стека
{
    node* elem; // Информационное поле
    int ch; // Уровень вершины
    no* sled; // Указатель на следующий элемент стека
};

class TREE // Определяем класс для работы с бинарным деревом
{
private:
    node* Tree; // Указатель на корень дерева
    void PushStack(no**, node**, int*); // Объявление функции для помещения элемента в стек
    void PopStack(no**, node**, int*); // Объявление функции для извлечения элемента из стека
    void VyvodStack(no**); // Объявление функции для вывода содержимого стека

public:
    TREE() { Tree = new(node); (*Tree).Right = NULL; } // Конструктор класса, инициализирующий корень дерева
    node* GetTreeRight() { return (*Tree).Right; } // Метод для получения указателя на правого потомка корня
    void  TreeSearch(int); // Метод для поиска вершины с заданным ключом в дереве
    void  VyvodTree(node*); // Метод для вывода дерева на экран
};

void main() // Главная функция программы
{
    setlocale(LC_ALL, "Rus"); // Устанавливаем русскую локаль

    TREE A; // Создаем объект класса TREE
    int el; // Переменная для хранения вводимых значений ключей

    cout << "Вводите значения информационных полей вершин: " << endl; 
    cin >> el; // Считываем первый ключ
    while (el != 0) // Цикл ввода ключей до ввода нуля
    {
        A.TreeSearch(el); cin >> el;
    } // Вызываем метод поиска и добавления вершины в дерево
    A.VyvodTree(A.GetTreeRight()); // Вызываем метод для вывода дерева на экран

    cout << "\n"; // Переход на новую строку
    system("PAUSE"); // Пауза перед завершением программы
}

void TREE::TreeSearch(int el) // Метод для поиска вершины с заданным ключом в дереве
{
    node* p1, * p2; // Указатели для поиска места вставки новой вершины
    int  d; // Переменная для определения направления движения по дереву

    p2 = Tree; p1 = (*p2).Right; d = 1; // Инициализация указателей и переменной
    while (p1 != NULL && d != 0) // Пока не достигнут конец дерева или не найдена вершина с таким же ключом
    {
        p2 = p1; // Переходим к следующему узлу
        if (el < (*p1).Key) { p1 = (*p1).Left; d = -1; } // Если ключ меньше текущего, идем влево
        else
            if (el > (*p1).Key) { p1 = (*p1).Right; d = 1; } // Если ключ больше текущего, идем вправо
            else  d = 0; // Если ключ равен текущему, завершаем поиск
    }
    if (d == 0)  (*p1).Count = (*p1).Count + 1; // Если найдена вершина с таким же ключом, увеличиваем счетчик
    else // Иначе
    {
        p1 = new(node); // Выделяем память под новую вершину
        (*p1).Key = el;  (*p1).Left = NULL; // Присваиваем значения ключу и указателю на левого потомка
        (*p1).Right = NULL;  (*p1).Count = 1; // Присваиваем значения указателю на правого потомка и счетчику
        if (d < 0) (*p2).Left = p1; // Если новая вершина должна быть левым потомком
        else  (*p2).Right = p1; // Иначе - правым потомком
    }
}

void TREE::VyvodTree(node* t) // Метод для вывода дерева на экран
{
    no* stk, * stk1; // Указатели на стеки для обхода дерева
    node* u; // Вспомогательный указатель на узел
    int i, n; // Переменные для циклов и уровня узла

    stk = stk1 = NULL; n = 0; // Инициализация стеков и переменной
    while (t != NULL) // Пока не пройдены все узлы дерева
    {
        PushStack(&stk1, &t, &n); // Помещаем узел во вспомогательный стек
        if ((*t).Right != NULL) // Если у текущего узла есть правый потомок
        {
            if ((*t).Left != NULL) PushStack(&stk, &((*t).Left), &n); // Если есть и левый, помещаем его в основной стек
            t = (*t).Right; // Переходим к правому потомку
        }
        else // Иначе
        {
            if ((*t).Left != NULL) // Если у текущего узла есть только левый потомок
            {
                if (stk1 != NULL) // Если во вспомогательном стеке есть элементы
                {
                    PopStack(&stk1, &u, &n); // Извлекаем из него узел
                    for (i = 0; i <= n; i++) cout << " "; // Выводим пробелы для отступа
                    cout << (*u).Key << endl; // Выводим ключ узла
                }
                t = (*t).Left; // Переходим к левому потомку
            }
            else // Иначе
                if (stk == NULL) t = NULL; // Если основной стек пуст, завершаем обход
                else // Иначе
                {
                    while ((*stk).elem != (*((*stk1).elem)).Left) // Пока в основном стеке не встретим узел с левым потомком
                    {
                        PopStack(&stk1, &u, &n); // Извлекаем узел из вспомогательного стека
                        for (i = 0; i <= n; i++) cout << " "; // Выводим пробелы для отступа
                        cout << (*u).Key << endl; // Выводим ключ узла
                    }
                    PopStack(&stk1, &u, &n); // Извлекаем узел с левым потомком
                    for (i = 0; i <= n; i++) cout << " "; // Выводим пробелы для отступа
                    cout << (*u).Key << endl; // Выводим ключ узла
                    PopStack(&stk, &t, &n); // Извлекаем из основного стека текущий узел
                }
        }
        n = n + 1; // Увеличиваем уровень узла
    }
    VyvodStack(&stk1); // Выводим оставшиеся узлы из вспомогательного стека
}

void TREE::PushStack(no** stk, node** el, int* n) // Функция для помещения элемента в стек
{
    no* q; // Вспомогательный указатель на элемент стека

    q = new(no); // Выделяем память под новый элемент стека
    (*q).elem = *el;  (*q).ch = *n; // Присваиваем значения элементу и уровню
    (*q).sled = *stk; *stk = q; // Добавляем элемент в стек
}

void TREE::PopStack(no** stk, node** t, int* n) // Функция для извлечения элемента из стека
{
    no* q; // Вспомогательный указатель на элемент стека

    if (*stk != NULL) // Если стек не пуст
    {
        *t = (**stk).elem; // Присваиваем указатель на элемент стека
        *n = (**stk).ch; // Присваиваем уровень элемента стека
        q = *stk; // Запоминаем адрес элемента стека
        *stk = (**stk).sled; // Перемещаем указатель на следующий элемент
        delete q; // Освобождаем память, выделенную под элемент стека
    }
}

void TREE::VyvodStack(no** stk) // Функция для вывода содержимого стека
{
    node* k; // Указатель на узел дерева
    int i, n; // Переменные для цикла и уровня узла

    while (*stk != NULL) // Пока стек не пуст
    {
        k = (**stk).elem; n = (**stk).ch; // Получаем указатель на узел и его уровень
        for (i = 0; i <= n; i++) cout << " "; // Выводим пробелы для отступа
        cout << (*k).Key << endl; // Выводим ключ узла
        *stk = (**stk).sled; // Переходим к следующему элементу стека
    }
}
