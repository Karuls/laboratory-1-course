#include<iostream>
using namespace std;

struct node
{
    int elem;
    node* sled;
};
class Spisok
{
private:
    node* ld, * rd;
    int el_left, el_right;
public:
    void POSTROENIE();
    void VYVOD();
    void VSTAV1(int);
    void VSTAV2(int);
    int SetElLeft() { return el_left; }
    int SetElRight() { return el_right; }
    void YDALE1();
    void YDALE2();
    void OCHISTKA();
};

void main()
{
    setlocale(LC_ALL, "Rus");
    Spisok A;
    int el;

    A.POSTROENIE(); A.VYVOD();
    cout << "Добавим звено справа.\n";
    cout << "Введите элемент добавляемого звена: ";
    cin >> el;
    A.VSTAV1(el); A.VYVOD();
    cout << "Добавим звено слева.\n";
    cout << "Введите элемент добавляемого звена: ";
    cin >> el;
    A.VSTAV2(el); A.VYVOD();
    cout << "Удалим звено справа.\n";
    A.YDALE1(); A.VYVOD(); cout << A.SetElRight() << endl;
    cout << "Удалим зввено слева.\n";
    A.YDALE2(); A.VYVOD(); cout << A.SetElLeft() << endl;
    A.OCHISTKA();

    cout << "\n";
    system("PAUSE");
}

// ld - указатель на левый конец дека,
// rd - Указатель на правый конец дека.
void Spisok::POSTROENIE()
{
    node* k; // Временный указатель на узел
    int el; // Элемент дека, вводимый пользователем

    cout << "Вводите содержимое звеньев дека: \n"; // Предложение для пользователя
    cin >> el; // Ввод первого элемента
    if (el != 0) // Если элемент не равен 0
    {
        k = new (node); // Выделение памяти под новый узел
        (*k).elem = el; (*k).sled = NULL; // Инициализация нового узла
        ld = k; rd = k; cin >> el; // Присваивание указателю на левый конец адреса первого узла
        while (el != 0) // Цикл, пока пользователь вводит ненулевые элементы
        {
            VSTAV1(el); cin >> el; // Вызов метода для вставки элемента справа
        }
    }
    else // Если первый элемент равен 0
    {
        rd = NULL; ld = NULL; // Установка указателей на конец дека в NULL
    }
}

// Метод VYVOD() для вывода содержимого дека:
// ld - указатель на левый конец дека.
void Spisok::VYVOD()
{
    node* k; // Временный указатель на узел

    k = ld;// присваивание временному указателю адреса левого конца
    cout << "Дек: "; 
    while (k != NULL) // Цикл, пока не достигнут конец дека
    {
        cout << (*k).elem << " "; k = (*k).sled; // Вывод элемента и переход к следующему узлу
    }
    cout << endl;
}


// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
void Spisok::VSTAV1(int el)
{
    node* k; // Временный указатель на узел

    k = new (node); // Выделение памяти под новый узел
    (*k).elem = el; (*k).sled = NULL; // Инициализация нового узла
    if (rd != NULL) // Если дек не пуст
    {
        (*rd).sled = k; rd = k; // Присоединение нового узла к деку справа
    }
    else // Если дек пуст
    {
        rd = k; ld = k; // Установка указателей на конец дека на новый узел
    }
}

// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
void Spisok::VSTAV2(int el)
{
    node* k; // Временный указатель на узел

    k = new (node); // Выделение памяти под новый узел
    (*k).elem = el; (*k).sled = ld; // Инициализация нового узла
    if (ld != NULL) ld = k; // Если дек не пуст, новый узел становится левым концом
    else { ld = k; rd = k; } // Если дек пуст, установка указателей на конец дека на новый узел
}
// Метод YDALE2() для удаления звена из дека справа
// с сохранением удаляемого звена в переменной el_right.
// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
void Spisok::YDALE1()
{
    node* z; // Временный указатель на узел
    node* k; // Временный указатель на узел

    if (rd == ld) // Если в деке только одно звено
    {
        el_right = (*rd).elem; delete rd; // Сохранение значения и удаление звена
        ld = rd = NULL;// Установка указателей на конец дека в NULL
        cout << "Дек пуст!\n"; 
    }
    else // Если в деке больше одного звена
    {
        z = ld; k = (*ld).sled; // Присваивание временным указателям адресов
        while (k != rd) // Пока не найдено звено, предшествующее правому концу
        {
            z = k; k = (*k).sled; // Переход к следующему звену
        }
        el_right = (*rd).elem; (*z).sled = NULL; delete rd; // Сохранение значения и удаление звена
        rd = z; // Установка правого конца на предыдущее звено
    }
}

// Метод YDALE2() для удаления звена из дека слева
// с сохранением удаляемого звена в переменной el_left.
// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
void Spisok::YDALE2()
{
    node* q; // Временный указатель на узел

    if (ld != NULL) // Если дек не пуст
    {
        el_left = (*ld).elem; q = ld; // Сохранение значения и присвоение временному указателю адреса левого конца
        ld = (*ld).sled; delete q; // Установка левого конца на следующее звено и удаление звена
    }
    else  cout << "Дек пуст!\n"; // Вывод сообщения, если дек пуст
}

// Метод OCHISTKA() для возврата выделенной памяти в "кучу".
void Spisok::OCHISTKA()
{
    node* k, * q; // Временные указатели на узлы

    k = ld; // Присваивание временному указателю адреса левого конца
    if (k != NULL) // Если дек не пуст
    {
        q = (*k).sled; // Присваивание временному указателю адреса следующего узла
        while (q != NULL) // Пока не достигнут конец дека
        {
            delete k; // Освобождение памяти, занимаемой текущим узлом
            k = q; // Переход к следующему узлу
            q = (*q).sled; // Переход к следующему узлу
        }
        delete k; // Освобождение памяти, занимаемой последним узлом
    }
}