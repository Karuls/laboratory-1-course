#include <iostream>
using namespace std;

// Определение структуры node для хранения элементов списка
struct node {
    int elem;     // Хранит значение элемента списка
    node* sled;   // Указатель на следующий элемент списка
};

// Определение класса Spisok для работы с односвязным списком
class Spisok {
private:
    node* phead;  // Указатель на загл звено списка
    node* Res;    // Рабочий указатель 
public:
    // Конструктор класса Spisok. Создает заглавное звено и инициализирует Res
    Spisok() { phead = new(node); Res = NULL; }

    // Деструктор класса Spisok. Освобождает память, выделенную для заглавного звена
    ~Spisok() { delete phead; }

    // Методы класса Spisok для работы с односвязным списком
    void POSTROENIE();   // Метод для построения списка
    void VYVOD();        // Метод для вывода содержимого списка
    node* POISK(int);    // Метод для поиска элемента в списке
    void InsAfter(int);  // Метод для вставки элемента после указанного в списке
    void InsBefore(int); // Метод для вставки элемента перед указанным в списке
    void Delete();       // Метод для удаления указанного элемента из списка
    void DelAfter();     // Метод для удаления элемента после указанного в списке
    void OCHISTKA();     // Метод для очистки всего списка
};


void main() {
    setlocale(LC_ALL, "rus");  
    Spisok A;                   // Создаем объект класса Spisok
    int el, el1;                // Объявляем переменные для хранения вводимых пользователем значений
    node* Res_Zn;               // Объявляем указатель на узел для сохранения результата поиска
    A.POSTROENIE();             // Вызываем метод POSTROENIE() для построения списка
    A.VYVOD();                  // Вызываем метод VYVOD() для вывода содержимого спискё
    cout << "\nВведите элемент звена, после которого ";
    cout << "осуществляется вставка: ";
    cin >> el;
    cout << "\nВведите элемент вставляемого звена: ";
    cin >> el1;
    if (A.POISK(el) != NULL) {  // Проверяем, существует ли элемент в списке.
        A.InsAfter(el1);        // Если элемент существует, вставляем новый элемент после него.
        A.VYVOD();              // После вставки выводим содержимое списка.
    }
    else {
        cout << "Звена с заданным элементом в кольце нет!";  
    }
    cout << "\nВведите элемент звена, перед которым ";
    cout << "осуществляется вставка: ";
    cin >> el;
    cout << "\nВведите элемент вставляемого звена: ";
    cin >> el1;

    if (A.POISK(el) != NULL) {  // Проверяем, существует ли элемент в списке
        A.InsBefore(el1);       // Если элемент существует, вставляем новый элемент перед ним
        A.VYVOD();              // После вставки выводим содержимое списка
    }
    else {
        cout << "Звена с заданным элементом в кольце нет!";  
    }
    cout << "\nВведите элемент удаляемого звена";
    cin >> el;

    if (A.POISK(el) != NULL) {  // Проверяем, существует ли элемент в списке
        A.Delete();             // Если элемент существует, удаляем его из списка
        A.VYVOD();              // После удаления выводим содержимое списка
    }
    else {
        cout << "Звена с заданным элементом в кольце нет!";  
    }
    cout << "Введите элемент звена ";
    cout << "после которого нужно удалять: ";
    cin >> el;
    if (A.POISK(el) != NULL) {  // Проверяем, существует ли элемент в списке
        A.DelAfter();           // Если элемент существует, удаляем элемент после него
        A.VYVOD();              // После удаления выводим содержимое списка
    }
    else {
        cout << "Звена с заданным элементом в кольце нет!"; 
    }

    A.OCHISTKA(); // Очищаем память, выделенную для списка
    cout << "\n";
    system("PAUSE"); // Ожидаем нажатия клавиши перед завершением программы
}


void Spisok::POSTROENIE()
// Функция для построения кольца односвязного списка
{
    node* t; // Временный указатель на тек звено списка
    int el; // Переменная для эл списка
    t = phead; // Установка временного указателя на начало списка (загл звено)
    (*t).sled = NULL; // Установка указателя следующего звена на NULL
    cout << "Вводите элементы кольца: ";
    cin >> el; // Ввод первого элемента списка
    while (el != 0) // Пока не введен нулевой элемент, продолжаем ввод
    {
        (*t).sled = new(node); // Создание нового звена списка
        t = (*t).sled; // Перемещение временного указателя на новое звено
        (*t).elem = el; // Присваивание введенного значения элементу списка
        cin >> el; // Ввод следующего элемента списка
    }
    (*t).sled = (*phead).sled; // Связывание последнего звена с заглавным, создавая кольцо.
}

void Spisok::VYVOD()
// Метод для вывода содержимого кольца односвязного списка.
{
    node* t; // Временный указатель на текущее звено
    t = (*phead).sled; // Устанавливаем временный указатель на начало списка
    cout << "Кольцо: "; 
    // Если список не пустой, выводим элементы кольца.
    if (t != NULL)
    {
        cout << (*t).elem << " "; // Выводим элемент первого звена
        t = (*t).sled; // Переходим к следующему звену

        // Пока не вернулись к началу кольца, выводим остальные элементы
        while (t != (*phead).sled)
        {
            cout << (*t).elem << " "; // Выводим текущий элемент
            t = (*t).sled; // Переходим к следующему звену
        }
    }
    else
    {
        cout << "пусто!\n";
    }
}

node* Spisok::POISK(int el)
// Метод для поиска элемента в кольце односвязного списка.
{
    node* t; // Временный указатель на текущее звено
    Res = NULL; // Обнуляем указатель на найденное звено
    t = (*phead).sled; // Устанавливаем временный указатель на начало списка
    // Пока не вернемся к началу кольца и не найдено звено
    while ((*t).sled != (*phead).sled && Res == NULL)
    {
        if ((*t).elem == el) // Если текущий элемент равен искомому
        {
            Res = t; // Устанавливаем указатель на найденное звено
        }
        else
        {
            t = (*t).sled; // Переходим к следующему звену
        }
    }
    // Проверяем последнее звено на соответствие искомому элементу
    if (Res == NULL && (*t).elem == el)
    {
        Res = t; // Устанавливаем указатель на найденное звено
    }
    return Res; // Возвращаем указатель на найденное звено (или NULL)
}

void Spisok::InsAfter(int el)
// Метод для вставки элемента после указанного звена в кольце односвязного списка.
{
    node* q; // Новое звено списка
    q = new(node); // Создаем новое звено
    (*q).elem = el; // Присваиваем ему значение
    (*q).sled = (*Res).sled; // Устанавливаем связь с последующим звеном
    (*Res).sled = q; // Устанавливаем связь с новым звеном
}

void Spisok::InsBefore(int el)
// Метод для вставки элемента перед указанным звеном в кольце односвязного списка.
{
    node* q; // Новое звено списка
    q = new(node); // Создаем новое звено
    (*q).elem = (*Res).elem; // Копируем значение текущего звена в новое звено
    (*q).sled = (*Res).sled; // Устанавливаем связь с последующим звеном
    (*Res).elem = el; // Присваиваем текущему звену новое значение
    (*Res).sled = q; // Устанавливаем связь с новым звеном
}


void Spisok::Delete()
// Метод для удаления указанного звена из кольца односвязного списка
{
    node* z, * q; // Указатели на предыдущее и удаляемое звено

    if ((*Res).sled != (*phead).sled) // Проверяем, что удаляемое звено не является последним в кольце
    {
        q = (*Res).sled; // Устанавливаем указатель на удаляемое звено
        (*Res).elem = (*q).elem; // Копируем значение из следующего звена в текущее
        (*Res).sled = (*q).sled; // Устанавливаем связь с последующим звеном
        delete q; // Освобождаем память удаляемого звена
    }
    else if ((*Res).sled == Res) // Проверяем, что удаляемое звено это единственное в кольце.
    {
        q = (*phead).sled; // Устанавливаем указатель на единственное звено
        (*phead).sled = NULL; // Удаляем ссылку на единственное звено
        delete q; // Освобождаем память единственного звена
        cout << "Кольцо пусто!"; 
    }
    else // Если удаляемое звено находится в середине кольца
    {
        z = phead; // Устанавливаем указатель на заглавное звено
        q = (*phead).sled; // Устанавливаем указатель на первое звено в кольце
        while (q != Res) // Пока не дойдем до удаляемого звена
        {
            z = q; // Перемещаем указатель на предыдущее звено
            q = (*q).sled; // Перемещаем указатель на следующее звено
        }
        (*z).sled = (*q).sled; // Устанавливаем связь между предыдущим и следующим звенами.
        delete q; // Освобождаем память.
    }
}


void Spisok::DelAfter()
// Метод для удаления следующего звена после указанного в кольце односвязного списка
{
    node* q; // Указатель на звено, которое нужно удалить

    if ((*Res).sled != (*phead).sled) // Проверяем что удаляемое звено не является послдним в кольце
    {
        q = (*Res).sled; // Устанавливаем указатель на удаляемое звено
        (*Res).sled = (*q).sled; // Устанавливаем связь между текущим и следующим звенами
        delete q; // Освобождаем память удаляемого звена
    }
    else if ((*Res).sled == Res) // Проверяем, что удаляемое звено - единственное в кольце.
    {
        q = (*phead).sled; // Устанавливаем указатель на единственное звено
        (*phead).sled = NULL; // Удаляем ссылку на единственное звено.
        delete q; // Освобождаем память.
        cout << "Кольцо пусто!"; 
    }
    else // Если удаляемое звено находится в середине кольца.
    {
        q = (*Res).sled; // Устанавливаем указатель на удаляемое звено.
        (*Res).sled = (*q).sled; // Устанавливаем связь между текущим и следующим звенами
        (*phead).sled = (*Res).sled; // Обновляем ссылку на начало кольца
        delete q; // Освобождаем память
    }
}



void Spisok::OCHISTKA()
// Метод для освобождения памяти, занятой всеми звеньями списка.
{
    node* q, * q1; // Указатели на предыдущее и текущее звено.
    q = phead; // Устанавливаем указатель на начало списка.
    q1 = (*q).sled; // Устанавливаем указатель на первое звено в списке
    // Проходим по всем звеньям списка и освобождаем память
    do {
        q = q1; // Переходим к следующему звену
        q1 = (*q1).sled; // Переходим к следующему звену
        delete q; // Освобождаем память предыдущего звена
    } while (q1 != (*phead).sled); // Повторяем, пока не вернемся к началу кольца.
}
