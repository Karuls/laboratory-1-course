#include<iostream>
using namespace std;


struct nodeVis // Структура для звена "висячей" части гирлянды
{
    int elem; // Инф. поле звена висюльки
    nodeVis* vniz; // Указатель на следующий элемент "висячей" части
};

// Структура для звена гирлянды
struct nodeGir
{
    int elem; // Инф. поле звена гирлянды
    nodeVis* vniz; // Указатель на "висячую" часть гирлянды
    nodeGir* sled; // Указатель на следующий элемент гирлянды
};

class GirVis // Класс, представляющий гирлянду с висячими элементами

{
private:
    nodeGir* phead; // Голова гирлянды
    nodeVis* pheadVis; // Голова "висячей" части
    void VisVyvod(); // Метод для вывода содержимого "висячей" части

public:
   
    GirVis() { phead = new (nodeGir); } // Конструктор класса
    ~GirVis() { delete phead; }// Деструктор класса

    // Для работы с висячей частью
    nodeVis* VisPostr(); // Построение "висячей" части
    nodeVis* VisPoisk(int); // Поиск элемента в висячей части
    void SetpheadVis(nodeVis* r) { pheadVis = r; } // Определение головы висячей части
    void VisVstav(nodeVis*, int); // Вставка элемента в висячую часть
    void Vis1Vstav(nodeVis*, int); // Вставка элемента перед указанным в висячей части
    void VisUdale(nodeVis*); // Удаление элемента из висячей части
    void Vis1Udale(nodeVis*); // Удаление указанного элемента из висячей части

    // Для работы с гирляндой

    void GirPostr(); // Построение гирлянды
    void GirVyvod(); // Вывод содержимого гирлянды
    nodeGir* GirPoisk(int); // Поиск элемнта в гирлянде

    // Для очистки памяти
    void OCHISTKA(); // Очистка гирлянды
    void OCHISTKA1(); // Очистка "висячей" части
};


void main()
{
    setlocale(LC_ALL, "Rus"); // Установка локали для корректного отображения текста на русском языке.
    GirVis A; // Создание объекта класса GirVis.

    int el, elGir, elVis; // Объявление переменных для хранения вводимых значений.
    nodeGir* Res; // Объявление указателя на звено гирлянды (рабочий указатель).
    nodeVis* ResVis; // Объявление указателя на звено висюльки.

    A.GirPostr(); // Вызов метода для построения гирлянды.
    A.GirVyvod(); // Вызов метода для вывода содержимого гирлянды.

    cout << "\nВведите элемент звена гирлянды, "; // 
    cout << "чьи висюльки будем изменять:\n";
    cin >> elGir; // Ввод значения элемента гирлянды от пользователя.

    cout << "\nВведите элемент звена висюльки, после которого "; 
    cout << "осуществляется вставка:\n";
    cin >> elVis; // Ввод значения элемента висюльки от пользователя.

    cout << "\nВведите вставляемый элемент:\n";
    cin >> el; // Ввод значения нового вставляемого элемента от пользователя.

    //Поиск элемента elGir в гирлянде.
    Res = A.GirPoisk(elGir); // Поиск элемента гирлянды с номером elGir.
    if (Res != NULL) // Если элемент найден:
    {
        // Устанавливаем указатель на голову висячей части гирлянды, чтобы начать поиск в висячих элементах
        A.SetpheadVis((*Res).vniz);
        ResVis = A.VisPoisk(elVis); // Поиск элемента в висячей части с номером elVis.
        if (ResVis != NULL)// Если элемент в висячей части найден:
            A.VisVstav(ResVis, el); // Вставляем новый элемент el после найденного элемента в висячей части
        else
            cout << "Элемента в висюльке нет!\n"; 
    }
    else
        cout << "Элемента в гирлянде нет\n";  
    A.GirVyvod();  // Выводим содержимое гирлянды после выполнения операций.

    cout << "\nВведите элемент гирлянды, чью висюльку будем изменять:\n";
    
    cin >> elGir;
    cout << "Введите элемент висюльки, перед которым ";
    cout << "осуществляется вставка:\n";
    
    cin >> elVis; // вводим номер элемента висюльки от пользователя
    cout << "Введите вставляемый элемент:\n";
    cin >> el; // вводим значение вставляемого элемента от пользователя
    Res = A.GirPoisk(elGir);// Поиск элемента гирлянды с номером elGir.

    // Если элемент найден в гирлянде:
    if (Res != NULL)
    {
        // Устанавливаем указатель на голову висячей части гирлянды для поиска в "висячих" элементах.
        A.SetpheadVis((*Res).vniz);

        // Поиск элемента в висячей части с номером elVis.
        ResVis = A.VisPoisk(elVis);

        // Если элемент найден в висячей части:
        if (ResVis != NULL)
            // Выполняем вставку нового элемента el перед найденным элементом в висячей части.
            A.Vis1Vstav(ResVis, el);
        else
            cout << "Элемента в висюльке нет!\n";
    }
    else
        cout << "Элемента в гирлянде нет!\n";
    A.GirVyvod();// Выводим содержимое гирлянды после выполнения операций.


    cout << "\nВведите элемент гирлянды, чью висюльку будем изменять:\n";
    cin >> elGir;// вводимномер элемента гирлянды 
    cout << "Введите элемент висюльки, после которого нужно удалить:\n";
    cin >> elVis; // вводим номер элемента висюльки 

    Res = A.GirPoisk(elGir);  // Поиск элемента гирлянды с номером elGir.

    
    if (Res != NULL)// Если элемент найден в гирлянде:
    {
        
        A.SetpheadVis((*Res).vniz);// Устанавливаем указатель на голову висячей части гирлянды для поиска в висячих элементах.
        ResVis = A.VisPoisk(elVis);// Поиск элемента в висячей части с номером elVis.

        // Если элемент найден в висячей части и у него есть следующий элемент:
        if ((ResVis != NULL) && ((*ResVis).vniz != NULL))
            // Удаляем следующий элемент после найденного в висячей части.
            A.VisUdale(ResVis);
        else
            
            cout << "Элемента в висюльке нет!\n";
    }
    else
        
        cout << "Элемента в гирлянде нет!\n";

    // Выводим содержимое гирлянды после выполнения операций.
    A.GirVyvod();


    
    cout << "\nВведите элемент гирлянды, чью висюльку будем изменять:\n";
    cin >> elGir;    // номер элемента гирлянды от пользователя.
    cout << "Введите элемент висюльки, который удаляется:\n";
    cin >> elVis;//  номер элемента висюльки от пользователя.
    // Поиск элемента гирлянды с номером elGir.
    Res = A.GirPoisk(elGir);

    // Если элемент найден в гирлянде:
    if (Res != NULL)
    {
        // Устанавливаем указатель на голову висячей части гирлянды для поиска в висячих элементах.
        A.SetpheadVis((*Res).vniz);

        // Поиск элемента в висячей части с номером elVis.
        ResVis = A.VisPoisk(elVis);

        // Если элемент найден в висячей части и у него есть следующий элемент:
        if ((ResVis != NULL) && ((*ResVis).vniz != NULL))
            // Удаляем найденный элемент в висячей части.
            A.Vis1Udale(ResVis);
        else
            cout << "Элемента в висюльке нет или он последний!\n";
    }
    else
        cout << "Элемента в гирлянде нет!\n";

    // Выводим содержимое гирлянды после выполнения операций.
    A.GirVyvod();
    // Очищаем память, выделенную для объектов гирлянды и висюльки.
    A.OCHISTKA();


    cout << "\n"; // обзац
    system("PAUSE"); // остановка выполнения программы до тех пор, пока пользователь н4е нажмет клавишу
}

void GirVis::OCHISTKA()
{
    nodeGir* q, * q1; // Объявление рабочих указателей
    q = phead; // Инициализация указателя q головой гирлянды
    q1 = (*q).sled; // Указатель q1 "опережает" указатель q, указывая на следующий элемент после головы
    // Перебираем элементы гирлянды.
    while (q1 != NULL)
    {
        q = q1; // Перемещаем указатель q на следующий элемент
        q1 = (*q1).sled; // Перемещаем указатель q1 на следующий элемент после текущего
        pheadVis = (*q).vniz; // Устанавливаем указатель на голову висячей части текущего элемента гирлянды
        OCHISTKA1(); // Вызываем метод для очистки висюльки текущего элемента
        delete q; // Освобождаем память текущего элемента гирлянды
    }
}

void GirVis::OCHISTKA1()
{
    nodeVis* q, * q1; // Объявление рабочих указателей
    q = pheadVis; // Установка указателя q на голову висячей части
    q1 = (*q).vniz; // Установка указателя q1 на первый элемент висячей части
    // Перебираем элементы висячей части
    while (q1 != NULL)
    {
        q = q1; // Перемещаем указатель q на следующий элемент
        q1 = (*q1).vniz; // Перемещаем указатель на следующий элемент после текущего
        delete q; // Освобождаем памятьтекущего эл висячей части
    }
}


void GirVis::GirPostr()
// Построение однонаправленного списка с заглавным звеном,
// заданного указателем phead (построение гирлянды).
{
    nodeGir* t; // Объявление указателя
    int el; // для вводимого пользователем значения
    t = phead; // Инициализация указателя t указателем на голову гирлянды
    (*t).sled = NULL; // Устанавливаем следующий элемент после головы равным NULL, чтобы указать на конец списка
    cout << "Вводите элемент гирлянды: \n";
    cin >> el; // Считываем первый элемент гирлянды от пользователя
    // Пока пользователь не введет 0 (окончание ввода):
    while (el != 0)
    {
        (*t).sled = new (nodeGir); // Создаем новый элемент гирлянды после текущего элемента
        t = (*t).sled; // Переходим к новому элементу
        (*t).elem = el; // Устанавливаем значение элемента равным введенному пользователем значению
        (*t).sled = NULL; // Устанавливаем следующий элемент после текущего равным NULL
        (*t).vniz = VisPostr(); // Рекурсивно строим висячую часть для текущего элемента
        cout << " Вводите элемент гирлянды: \n"; // Выводим приглашение для ввода следующего элемента гирлянды.
        cin >> el; //ввод следующий элемент гирлянды 
    }
}


nodeVis* GirVis::VisPostr()
// Построение однонаправленного списка с заглавным звеном
// (построение висюльки). pheadVis - указатель на висюльку.
{
    nodeVis* t; // Объявление указателя на текущий элемент висюльки
    int el; // Переменная для вводимого пользователем значения
    // Создаем заглавное звено списка.
    pheadVis = new (nodeVis);
    t = pheadVis; // Устанавливаем указатель t на заглавное звено.
    (*t).vniz = NULL; // Устанавливаем ссылку на следующий элемент равной NULL, чтобы указать на конец списка.
    cout << "Вводите элементы звеньев висюльки: \n"; 
    cin >> el; // Считываем первый элемент висюльки от пользователя
    // Пока пользователь не введет 0 (окончание ввода):
    while (el != 0)
    {
        (*t).vniz = new (nodeVis); // Создаем новый элемент висюльки после текущего элемента
        t = (*t).vniz; // Переходим к новому элементу
        (*t).elem = el; // Устанавливаем значение элемента равным введенному пользователем значению
        (*t).vniz = NULL; // Устанавливаем ссылку на следующий элемент равной NULL
        cin >> el; // вводим следующий элемент висюльки от пользователя
    }

    return pheadVis; // Возвращаем указатель на заглавное звено висюльки
}



void GirVis::GirVyvod()
// Вывод содержимого однонаправленного списка, заданного
// указателем phead (вывод содержимого гирлянды).
{
    nodeGir* t; // Объявление указателя на текущий элемент гирлянд
    t = phead; // Устанавливаем указатель t на голову гирлянды
    t = (*t).sled; // Переходим к первому элементу гирлянды, пропуская заглавное звено
    cout << "Гирлянда: ";
    // Пока не достигнут конец списка:
    while (t != NULL)
    {
        cout << (*t).elem << " "; // Выводим значение элемента гирлянды
        pheadVis = (*t).vniz; // Устанавливаем указатель на висячую часть текущего элемента
        VisVyvod(); // Вызываем метод для вывода содержимого висячей части
        t = (*t).sled; // Переходим к следующему элементу гирлянды
    }
}


nodeGir* GirVis::GirPoisk(int el)
// Поиск элемента el в списке, заданном указателем phead.
// В случае успешного поиска возвращается адрес звена списка,
// содержащего элемент el. В противном случае - NULL.
{
    nodeGir* t, * r; // Объявление указателей для перемещения по списку и для хранения результата поиска
    r = NULL; // указатель r со значением NULL (результат поиска)
    t = phead; // Устанавливаем указатель t на голову списка гирлянды.
    t = (*t).sled; // Переходим к первому элементу гирлянды, пропуская заглавное звено
    // Пока не достигнут конец списка и результат поиска не установлен:
    while (t != NULL && r == NULL)
    {
        if ((*t).elem == el) // Если значение текущего элемента равно искомому значению:
            r = t; // Устанавливаем указатель r на текущий элемент списка
        else
            t = (*t).sled; // Переходим к следующему элементу гирлянды.
    }
    return r; // Возвращаем результат поиска (указатель на найденный элемент или NULL)
}


void GirVis::VisVyvod()
// Вывод содержимого однонаправленного списка с заглавным звеном,
// заданного указателем pheadVis (вывод содержимого висюльки).
{
    nodeVis* t; // Объявление указателя на текущий элемент висюлькии
      t = pheadVis; // Устанавливаем указатель t на голову висюльки
    t = (*t).vniz; // Переходим к первому элементу висюльки, пропуская заглавное звено.
    cout << "(";
    // Пока не достигнут конец висюльки:
    while (t != NULL)
    {
        cout << (*t).elem << " "; // Выводим значение текущего элемента висюльки.
        t = (*t).vniz; // Переходим к следующему элементу висюльки.
    }
    cout << ")";
}


nodeVis* GirVis::VisPoisk(int el)
// Поиск элемента el в списке, заданном указателем pheadVis.
// В случае успешного поиска возвращается адрес звена списка,
// содержащего элемент el. В противном случае - NULL.
{
    nodeVis* t, * r; // Объявление указателей для перемещения по списку и для хранения результата поиска.
    r = NULL; //указателя r значением NULL (рез поиска)
    t = pheadVis; // Устанавливаем указатель t на голову списка висюльки
    t = (*t).vniz; // Переходим к первому элементу висюльки, пропуская заглавное звено
    // Пока не достигнут конец списка и результат поиска не установлен:
    while (t != NULL && r == NULL)
    {
        if ((*t).elem == el) // Если значение текущего элемента равно искомому значению:
            r = t; // Устанавливаем указатель r на текущий элемент списка
        else
            t = (*t).vniz; // Переходим к следующему элементу висюльки
    }
    return r; // Возвращаем результат поиска , то есть указатель на найденный элемент или NULL
}


void GirVis::VisVstav(nodeVis* r, int el)
// Включение звена с информационным полем el
// после звена, на которое указывает r
// (включение звена в висюльку).
{
    nodeVis* q; // Объявление
    q = new (nodeVis); // Создание нового звена висюльки
    (*q).elem = el; // Присваивание информационному полю нового звена значения el
    (*q).vniz = (*r).vniz; // Установка ссылки нового звена на следующий элемент после r
    (*r).vniz = q; // Установка ссылки r на новый элемент
    // Теперь новый элемент q вставлен после элемента, на который указывает r
}


void GirVis::Vis1Vstav(nodeVis* r, int el)
// Включение звена с информационным полем el
// перед звеном, на которое указывает r
// (включение звена в висюльку).
{
    nodeVis* q; // Объявление указателя на новый элемент висюльки.
    q = new (nodeVis); // Создание нового звена висюльки.
    (*q).elem = (*r).elem; // Копирование значения информационного поля из элемента r в элемент q.
    (*q).vniz = (*r).vniz; // Копирование ссылки на следующий элемент после r в элемент q.
    (*r).elem = el; // Присваивание инф полю элемента r значения el.
    (*r).vniz = q; // Установка ссылки элемента r на новый элемент q.
    // Теперь новый элемент q вставлен перед элементом r.
}


void GirVis::VisUdale(nodeVis* r)
// Удаление звена, расположенного после звена,
// на которое указывает ссылка r
// (удаление звена висюльки).
{
    nodeVis* q; // Объявление указателя на удаляемый элемент висюльки
    q = (*r).vniz; // Присваивание указателю q ссылки на элемент после r
    if ((*r).vniz != NULL) // Проверка, не является ли элемент после r последним
    {
        (*r).vniz = (*(*r).vniz).vniz; // Перенаправление ссылки на следующий элемент после r
        delete q; // Удаление элемента, на который указывает q
    }
    else
    {
        cout << "Звено с заданным элементом - последнее!\n"; 
    }
}

void GirVis::Vis1Udale(nodeVis* r)
// Удаление звена, на которое указывает ссылка r
// (удаление звена висюльки).
{
    nodeVis* g; // Объявление указателя на элемент, который будет удален
    if ((*r).vniz != NULL) // Проверка, существует ли элемент после r
    {
        g = (*r).vniz; // Присваивание указателю g ссылки на элемент после r
        (*r).elem = (*(*r).vniz).elem; // Копирование значения информационного поля из элемента после r в элемент 
        (*r).vniz = (*(*r).vniz).vniz; // Перенаправление ссылки на следующий элемент после r
        delete g; // Удаление элемента, на который указывает 
    }
    else
    {
        cout << "Не умею удалять последнее звено!\n"; // Вывод сообщения, если элемент после r не существует
    }
}
