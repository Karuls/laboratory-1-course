#include <iostream>
using namespace std;

struct node
{
    int elem;     // Хранит значение элемента списка
    node* sled;   // Указатель на следующий элемент спискаа
    node* pred; // Указатель на предыдущий элемент списка
};

class Spisok
{
private:
    node* nsp; // Указатель на заглавное звено списка
public:
    Spisok() { nsp = NULL; } // Конструктор класса, инициализирует указатель как NULL
    void BuiltRing(); // Метод для построения кольцевого списка
    void VyvodLeftRight(); // Вывод содержимого списка по часовой стрелке
    void VyvodRightLeft(); // Вывод содержимого списка против часовой стрелки
    void InsAfter(node*, int); // Вставка элемента после указанного звена
    void InsBefore(node*, int); // Вставка элемента перед указанным звеном
    void Delete(node*); // Удаление указанного звена
    void DelAfter(node*); // Удаление звена после указанного звена
    node* SearchRing(int); // Поиск звена по его элементу
    void Ochistka(); // Очистка памяти, освобождение занимаемых звеньев
};


void main()
{
    setlocale(LC_ALL, "Rus");   // Устанавливаем локаль для корректного отображения русских символов.

    Spisok A;                   // Создаем объект класса Spisok.

    node* Res;                  // Указатель на узел списка.
    int el, el1;                // Переменные для хранения элементов.

    A.BuiltRing();              // Создаем кольцевой список.

    cout << "Содержимое кольца 'по часовой стрелке': \n";
    A.VyvodLeftRight();
    cout << "Содержимое кольца 'против часовой стрелки': \n";
    A.VyvodRightLeft();
    cout << "Введите элемент звена, после которого ";
    cout << "осуществляется вставка: ";
    cin >> el;
    cout << "Введите элемент вставляемого звена: ";
    cin >> el1;
    Res = A.SearchRing(el);     // Ищем элемент в списке.
    if (Res != NULL) {          // Если элемент найден, выполняем вставку.
        A.InsAfter(Res, el1);
        A.VyvodLeftRight();     // Выводим содержимое списка.
    }
    else {
        cout << "Звена с таким элементом в списке нет!\n"; 
    }
    cout << "Введите элемент звена, перед которым ";
    cout << "осуществляется вставка: ";
    cin >> el;
    cout << "Введите элемент вставляемого звена: ";
    cin >> el1;
    Res = A.SearchRing(el);     // Ищем элемент в списке.
    if (Res != NULL) {          // Если элемент найден, выполняем вставку.
        A.InsBefore(Res, el1);
        A.VyvodLeftRight();     // Выводим содержимое списка.
    }
    else {
        cout << "Звена с таким элементом в списке нет!\n";  
    }
    cout << "Введите элемент звена, который ";
    cout << "надо удалить: ";
    cin >> el; 
    Res = A.SearchRing(el);     // Ищем элемент в списке.
    if (Res != NULL) {          // Если элемент найден, выполняем удаление.
        A.Delete(Res);
        A.VyvodLeftRight();     // Выводим содержимое списка.
    }
    else {
        cout << "Звена с таким элементом в списке нет!\n";
    }
    cout << "Введите элемент звена, после которого ";
    cout << "осуществляется удаление: ";
    cin >> el;
    Res = A.SearchRing(el);     // Ищем элемент в списке.
    if (Res != NULL) {          // Если элемент найден, выполняем удаление.
        A.DelAfter(Res);
        A.VyvodLeftRight();     // Выводим содержимое списка.
    }
    else {
        cout << "Звена с таким элементом в списке нет!\n";  
    }
    A.Ochistka(); // Очищаем память, выделенную для списка.
    cout << "\n";
    system("PAUSE"); // Ожидаем нажатия клавиши перед завершением программы.
}


void Spisok::BuiltRing()
// Построение двунаправленного кольцевого списка nsp
// с удаленным заглавным звеном.
// nsp - указатель на заглавное звено списка.
{
    node* r; // Объявление указателя
    int el; // Объявление переменной для вводимых пользователем эл списка

    //Построение заглавное звена кольцевого списка
    nsp = new(node); // Выделение памяти под заглавное звено и он же есть nsp
    r = nsp; // Присваивание r значение заглавного звена
    (*nsp).pred = NULL; (*nsp).sled = NULL; // Установка указателей предыдущего и следующего звеньев заглавного звена на NULL
    cout << "Вводите элементы списка: \n"; 
    cin >> el; // Ввод пользоватедя эл списка
    while (el != 0) // Цикл продолжается, пока не будет введен 0
    {
        (*r).sled = new (node); // Создание нового звена списка и присвоение указателю на следующий элемент адреса этого звена
        (*((*r).sled)).pred = r; // Установка указателя на предыдущий элемент нового звена на тек элемент
        r = (*r).sled; // Перемещение указателя r на новое звено
        (*r).sled = NULL; // Установка указателя на следующий элемент нового звена на NULL
        (*r).elem = el; // Присваивание элементу нового звена значения, введеного пользователем
        cin >> el; // Ввод пользоватедя эл списка
    }
    // образуем кольцевой список
    if ((*nsp).sled != NULL) // Проверка, не является ли список пустым
    {
        (*((*nsp).sled)).pred = r; // Установка указателя на предыдущий элемент первого звена на последний элемент списка
        (*r).sled = (*nsp).sled; // Установка укателя на следующий элемент последнего звена на первый элемент списка
    }
    else // Если список пуст
        cout << "Кольцевой список пуст!\n"; 
}


void Spisok::VyvodLeftRight()
// Вывод содержимого двунаправленного кольцевого списка
// с удаленным заглавным звеном "по часовой стрелке".
// nsp - указатель на заглавное звено списка.
{
    node* r; // Объявление указателя r на звено списка

    cout << "Кольцевой список: "; 
    if ((*nsp).sled != NULL) // Проверка, не является ли список пустым
    {
        cout << (*((*nsp).sled)).elem << " "; // Вывод значения элемента первого звена списка
        r = (*((*nsp).sled)).sled; // Присваивание указателю r адреса следующего за первым звена
        while (r != (*nsp).sled) // Цикл продолжается, пока не дойдет до начального звена списка
        {
            cout << (*r).elem << " "; // Вывод значения элемента текущего звена
            r = (*r).sled; // Переход к следующему звену
        }
        cout << endl; 
    }
    else cout << "пуст!"; 
}


void Spisok::VyvodRightLeft()
// Вывод содержимого двунаправленного кольцевого списка
// с удаленным заглавным звеном "против часовой стрелки".
// nsp - указатель на заглавное звено списка.
{
    node* r; // Объявление указателя 
    cout << "Кольцевой список: "; 
    if ((*nsp).sled != NULL) // Проверка, не является ли список пустым
    {
        cout << (*((*((*nsp).sled)).pred)).elem << " "; // Вывод значения элемента последнего звена списка
        r = (*((*((*nsp).sled)).pred)).pred; // Присваивание указателю r адреса предыдущего за последним звена
        while (r != (*((*nsp).sled)).pred) // Цикл продолжается, пока не дойдет до начального звена списка
        {
            cout << (*r).elem << " "; // Вывод значения элемента текущего звена
            r = (*r).pred; // Переход к предыдущему звену
        }
        cout << endl;
    }
    else cout << "пуст!"; 
}


node* Spisok::SearchRing(int el)
// Поиск элемента el в кольцевом двунаправленном списке
// с удаленным заглавным звеном.
// nsp - указатель на заглавное звено списка.
{
    node* q; // Объявление указателя на звено списка
    node* p; // Объявление указателя 
    node* Res; // Объявление указателя для хранения результата поиска
    Res = NULL; //  указатель со значением NULL
    p = nsp; // Присваивание указателю p адреса заглавного звена списка
    if ((*((*p).sled)).elem == el) Res = (*p).sled; // Проверка, является ли первый элемент списка искомым
    else
    {
        q = (*((*p).sled)).sled; // Присваивание указателю q адреса второго звена списка
        while (q != (*p).sled && Res == NULL) // Цикл продолжается, пока не пройдет весь список или не найден искомый элемент
            if ((*q).elem == el) Res = q; // Если текущий элемент списка равен искомому, присваиваем его указателю Res
            else  q = (*q).sled; // Переход к следующему звену списка
    }
    return Res; // Возвращаем найденный элемент или NULL, если элемент не найден
}


void Spisok::InsAfter(node* Res, int el)
// Вставление в кольцевой двунаправленный список звена
// с информационным полем el после  звена, на  которое
// указывает ссылка Res.
{
    node* q; // Объявление указателя 
    q = new(node); // Выделение памяти под новое звено и присвоение адреса этой памяти указателю q
    (*q).elem = el; // Присвоение инф полю нового звена значения el
    (*q).sled = (*Res).sled; // Присвопение указателю на следующее звено нового звена адрес следующего звена после Res
    (*q).pred = (*(*Res).sled).pred; // Присвоение указателю на предыдущее звено нового звена адрес предыдущего звена после Res
    (*(*Res).sled).pred = q; // Присвоение предыдущему звену после Res адреса нового звена
    (*Res).sled = q; // Присвоение Res адреса нового звена
}


void Spisok::InsBefore(node* Res, int el)
// Вставка в кольцевой двунаправленный список звена
// с информационным полем el перед звеном, на  которое
// указывает ссылка Res.
// nsp - указатель на заглавное звено списка.
{
    node* q; // Объявление указателя на новое звено

    q = new(node); // Выделение памяти под новое звено и рн жн теперь q
    (*q).elem = el; // Присвоение инфоу полю нового звена значения el
    (*q).sled = (*(*Res).pred).sled; // Присвоение указателю на следующее звено нового звена адрес следующего звена перед Res
    (*q).pred = (*Res).pred; // Присвоение указателю на предыдущее звено нового звена адрес предыдущего звена перед Res
    (*(*Res).pred).sled = q; // Присвоение следующему звену перед Res адреса нового звена
    (*Res).pred = q; // Присвоение Res адреса нового звена
    if (Res == (*nsp).sled) (*nsp).sled = q; // Если Res указывает на первое звено в списке, то обновляем указатель списка на новое звено
}


void Spisok::Delete(node* Res)
// Удаление из кольцевого двунаправленного списка
// звена, на которое указывает ссылка Res.
// nsp - указатель на заглавное звено списка.
{
    if ((*Res).sled == Res) // Проверка, является ли указ. Res последним звеном в списке
    {
        (*nsp).sled = NULL; // Если да, то обнуляем указатель на следующее звено в заглавном звене
        delete Res; // Удаляем последнее звено
    }
    else
    {
        (*(*Res).sled).pred = (*Res).pred; // Присваиваем следующему звену перед Res адрес предыдущего звена перед Res
        (*(*Res).pred).sled = (*Res).sled; // Присваиваем предыдущему звену перед Res адрес следующего звена после Res
        if ((*nsp).sled == Res)
            // Удаляем "первое" звено кольца.
            (*nsp).sled = (*Res).sled; // Если Res указывает на первое звено в списке, то обновляем указатель списка на следующее звено после Res
        delete Res; // Удаляем звено, на которое указывает Res
    }
}


void Spisok::DelAfter(node* Res)
// Удаление из кольцевого двунаправленного списка звена,
// расположенного после звена, на которое указывает
// ссылка Res.
// nsp - указатель на заглавное звено списка.
{
    node* q; // Объявление указателя q

    if ((*Res).sled == Res) // Проверка, является ли Res последним звеном в списке
    {
        (*nsp).sled = NULL; // Если да, то обнуляем указатель на следующее звено в заглавном звене
        delete Res; // Удаляем последнее звено
    }
    else
    {
        q = (*Res).sled; // Присваиваем q следующее звено после Res
        (*(*(*Res).sled).sled).pred = (*(*Res).sled).pred; // Присваиваем следующему звену после Res адрес предыдущего звена перед следующим звеном после Res
        (*Res).sled = (*(*Res).sled).sled; // Присваиваем Res адрес следующего звена после следующего звена после Res
        if ((*(*nsp).sled).pred == Res)
            // Удаляем "последнее" звено кольца.
            (*nsp).sled = (*Res).sled; // Если Res указывает на последнее звено в списке, то обновляем указатель списка на следующее звено после Res
        delete q; // Удаляем следующее звено после Resт т есть q
    }
}


void Spisok::Ochistka()
// Освобождение памяти, выделенной под кольцевой 2-направ. список
{
    node* q, * q1; // Объявление указателей q и q1

    q = (*((*nsp).sled)).sled; // Присваивание q адреса второго звена в списке
    q1 = (*q).sled; // Присваивание q1 адреса третьего звена в списке
    while (q1 != (*((*nsp).sled)).sled) // Пока q1 не указывает на второе звено в списке
    {
        delete q; // Удаление текущего звена
        q = q1; // Переход к следующему звену
        q1 = (*q1).sled; // Обновление адреса следующего звена
    }
    delete q; // Удаление последнего звена
    delete nsp; // Удаление заглавного звена
}
