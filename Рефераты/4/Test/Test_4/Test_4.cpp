#include<iostream>
using namespace std;

// Структура для элемента стека
struct node
{
    int elem; // Информационное поле
    node* sled; // Указатель на следующий элемент
};

// Класс для работы со стеком
class Spisok
{
private:
    node* stk; // Указатель на вершину стека
    int klad; // Поле для хранения извлеченного элемента
public:
    Spisok() { stk = NULL; } // Конструктор класса, инициализирует вершину стека как NULL
    int Set_Stack() { return klad; } // Метод для возврата значения поля klad
    void POSTROENIE(); // Метод для построения стека
    void VYVOD(); // Метод для вывода содержимого стека
    void W_S(int); // Метод для помещения элемента в стек
    void YDALENIE(); // Метод для удаления элемента из стека
    void OCHISTKA(); // Метод для освобождения памяти, выделенной под стек
};

// Основная функция программы
void main()
{
    setlocale(LC_ALL, "Rus"); // Установка локали для вывода на русском языке
    Spisok A; // Создание объекта класса Spisok
    int  el; // Переменная для вводимого элемента

    A.POSTROENIE(); // Построение стека
    A.VYVOD(); // Вывод содержимого стека
    cout << "Введите вставляемый элемент: ";
    cin >> el; // Ввод элемента для вставки в стек
    A.W_S(el); // Вставка элемента в стек
    A.VYVOD(); // Вывод содержимого стека после вставки

    cout << "Удалим элемент из стека.\n";
    A.YDALENIE(); // Удаление элемента из стека
    int t = A.Set_Stack(); // Получение извлеченного элемента из стека
    cout << "Из стека было извлечено число... " << t << endl; 
    A.VYVOD(); // Вывод содержимого стека после удаления
    A.OCHISTKA(); // Освобождение памяти, выделенной под стек

    cout << "\n";
    system("PAUSE"); // Приостановка выполнения программы перед закрытием окна
}

// Метод POSTROENIE() для построения стека, заданного указателем stk.
void Spisok::POSTROENIE()
{
    node* t; // Временный указатель на узел
    int el; // Переменная для вводимого элемента

    cout << "Вводите элементы стека: ";
    cin >> el; // Ввод первого элемента стека
    while (el != 0) // Пока вводимый элемент не равен 0
    {
        t = new (node); // Создание нового узла
        (*t).elem = el; // Запись значения в информационное поле узла
        (*t).sled = stk; // Присваивание указателю на следующий узел адреса вершины стека
        stk = t; // Перемещение вершины стека на новый узел
        cin >> el; // Считывание следующего ввода
    }
}



void Spisok::VYVOD()
{
    node* t; // Временный указатель на узел

    cout << "Содержимое стека: "; 
    t = stk; // Начальное присваивание временному указателю адреса вершины стека
    while (t != NULL) // Пока временный указатель не указывает на нуль (конец стека)
    {
        cout << (*t).elem << " "; // Вывод элемента стека
        t = (*t).sled; // Переход к следующему элементу стека
    }
    cout << endl;
}


// Метод W_S(int el) для помещения элемента el в стек stk.
void Spisok::W_S(int el)
{
    node* q; // Временный указатель на узел

    q = new (node); // Создание нового узла в куче
    (*q).elem = el; // Присваивание новому узлу значение элемента el
    (*q).sled = stk; // Присваивание новому узлу адреса предыдущей вершины стека
    stk = q; // Обновление указателя на вершину стека
}


// Значение информационного поля удаляемого элемента помещается в параметр klad.
void Spisok::YDALENIE()
{
    node* q; // Временный указатель на узел

    if (stk == NULL) // Проверка, пуст ли стек
        cout << "Стек пуст!\n";
    else
    {
        klad = (*stk).elem; // Сохранение значения элемента для возврата
        q = stk; // Присваивание временному указателю адреса вершины стека
        stk = (*stk).sled; // Обновление указателя на вершину стека
        delete q; // Освобождение памяти, занимаемой удаляемым узлом
    }
}


// Метод OCHISTKA() для возврата выделенной памяти в "кучу"
void Spisok::OCHISTKA()
{
    node* t, * q; // Временные указатели на узлы

    t = stk; // Присваивание временному указателю адреса вершины стека
    if (t != NULL) // Проверка, пуст ли стек
    {
        q = (*t).sled; // Присваивание временному указателю адреса следующего узла
        while (q != NULL) // Пока не достигнут конец стека
        {
            delete t; // Освобождение памяти, занимаемой текущим узлом
            t = q; // Переход к следующему узлу
            q = (*q).sled; // Переход к следующему узлу
        }
        delete t; // Освобождение памяти, занимаемой последним узлом
    }
}
